{"meta":{"title":"Chankin's Blogs","subtitle":"以梦为马不负韶华","description":"Grasp All,Lose All.","author":"Chankin","url":"http://chankin.tech"},"pages":[{"title":"About","date":"2018-09-27T12:01:10.000Z","updated":"2018-09-27T12:18:22.958Z","comments":true,"path":"About/index.html","permalink":"http://chankin.tech/About/index.html","excerpt":"","text":"Java 都十分骄傲了圣诞节了"},{"title":"Categories","date":"2018-09-27T12:16:47.000Z","updated":"2018-09-27T17:28:58.117Z","comments":false,"path":"categories/index.html","permalink":"http://chankin.tech/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-09-27T11:58:34.000Z","updated":"2018-09-27T17:28:44.696Z","comments":false,"path":"tags/index.html","permalink":"http://chankin.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"寻找两座城市之间的最小飞行次数的问题","slug":"寻找两座城市之间的最小飞行次数的问题","date":"2018-10-03T09:08:02.000Z","updated":"2018-10-03T09:43:57.559Z","comments":true,"path":"2018/10/03/寻找两座城市之间的最小飞行次数的问题/","link":"","permalink":"http://chankin.tech/2018/10/03/寻找两座城市之间的最小飞行次数的问题/","excerpt":"","text":"​ &ensp;&ensp;&ensp; 图对现实世界的问题的建模和解决非常有用。 例如,可以使用图对找寻两座城市之间最小飞行次数的问题进行建模，其中顶点代表城市,边代表两座相邻城市之间的航班。将最小飞行次数的问题就简化为找寻图中两个顶点之间的最短路径问题。 图可以用来对城市之间的飞行次数进行建模 &ensp;&ensp;&ensp;1736年伦纳德·欧拉创立了图论，当时他将地图术语用来解决著名的哥尼斯堡七孔桥.位于普鲁士的哥尼斯堡(现俄罗斯的加里宁格勒)被普罗格河分开，该河流经两座岛，这座城市和岛由七座桥相连。问题在于，如何经过没做桥一次且只经过一次,然后返回起点? 欧拉证明了这是不可能的. &ensp;&ensp;&ensp;为了证明这个结论，欧拉首先通过删除所有的街道来提取出哥尼斯堡的地图。并得到了如下图所示的草图。然后，他将每一块陆地用一个点来替换，这个点称为顶点(vertex) 或者结点(node)，并且将每一座桥用一条线来替换，这条线称为边边(edge)。这种有顶点和边的结构称为图(graph)。 &ensp;&ensp;&ensp;当看见图的时候，我们会询问是否存在一条从任意顶点出发的路径，这条路径遍历所有的边一次且只有一次，然后返回起始顶点。欧拉证明了这种路径存在的条件是，每个顶点必 须拥有偶数条边。因此，哥尼斯堡的七孔桥问题没有解决的方法。 &ensp;&ensp;&ensp;图问题经常通过算法来解决。图算法广泛应用于不同的领域，例如，计算机科学、数学、 生物学、工程学、经济学、遗传学和社会科学。下面代码运用深度优先搜索和广度优先搜索来解决最短路径问题。 图可以用来对城市之间的飞行次数进行建模 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;import java.util.Arrays;/** 寻找两座城市之间的最小飞行次数问题化简为找寻图中两个顶点之间的最短距离** 使用线性表、边数组、边对象、邻接矩阵和邻接线性表来表示顶点(代表城市)和边(代表两城市之间的航班)** 使用Gragh接口、AbstractGraph类和UnweightedGraph类来对图建模* 使用二叉树对图进行遍历* 并使用dfs和bfs回溯地图中的所有节点** */public class TestGraph &#123; public static void main(String[] args) &#123; String[] vertices = &#123;\"Beijing\", \"Shanghai\", \"Wuhan\", \"Nanjing\", \"Fuzhou\", \"Heilongjian\", \"Tianjin\", \"Hong kong\", \"Atlanta\", \"Guangdong\", \"Qiqihaer\", \"Hangzhou\"&#125;; int[][] edges = &#123; &#123;0, 1&#125;, &#123;0, 3&#125;, &#123;0, 5&#125;, &#123;1, 0&#125;, &#123;1, 2&#125;, &#123;1, 3&#125;, &#123;2, 1&#125;, &#123;2, 3&#125;, &#123;2, 4&#125;, &#123;2, 10&#125;, &#123;3, 0&#125;, &#123;3, 1&#125;, &#123;3, 2&#125;, &#123;3, 4&#125;, &#123;3, 5&#125;, &#123;4, 2&#125;, &#123;4, 3&#125;, &#123;4, 5&#125;, &#123;4, 7&#125;, &#123;4, 8&#125;, &#123;4, 10&#125;, &#123;5, 0&#125;, &#123;5, 3&#125;, &#123;5, 4&#125;, &#123;5, 6&#125;, &#123;5, 7&#125;, &#123;6, 5&#125;, &#123;6, 7&#125;, &#123;7, 4&#125;, &#123;7, 5&#125;, &#123;7, 6&#125;, &#123;7, 8&#125;, &#123;8, 4&#125;, &#123;8, 7&#125;, &#123;8, 9&#125;, &#123;8, 10&#125;, &#123;8, 11&#125;, &#123;9, 8&#125;, &#123;9, 11&#125;, &#123;10, 2&#125;, &#123;10, 4&#125;, &#123;10, 8&#125;, &#123;10, 11&#125;, &#123;11, 8&#125;, &#123;11, 9&#125;, &#123;11, 10&#125; &#125;; Graph&lt;String&gt; graph1 = new UnweightedGraph&lt;&gt;(vertices, edges); System.out.println(\"The number of vertices in graph1: \" + graph1.getSize()); System.out.println(\"The vertex with index 1 is \" + graph1.getVertex(1)); System.out.println(\"The index for Shanghai is \" + graph1.getIndex(\"Shanghai\")); System.out.println(\"The edges for graph1:\"); graph1.printEdges(); String[] names = &#123;\"Jack Ma\", \"Pony Ma\", \"李彦宏\", \"雷军\", \"刘东强\"&#125;; ArrayList&lt;AbstractGraph.Edge&gt; edgeList = new ArrayList&lt;&gt;(); edgeList.add(new AbstractGraph.Edge(0, 2)); edgeList.add(new AbstractGraph.Edge(1, 2)); edgeList.add(new AbstractGraph.Edge(2, 4)); edgeList.add(new AbstractGraph.Edge(3, 4)); Graph&lt;String&gt; graph2 = new UnweightedGraph&lt;&gt;(Arrays.asList(names), edgeList); System.out.println(\"\\nThe number of vertices in graph2: \" + graph2.getSize()); System.out.println(\"The edges for graph2:\"); graph2.printEdges(); &#125;&#125; 12345678910111213141516171819202122232425public interface Graph&lt;V&gt; &#123; public int getSize(); public java.util.List&lt;V&gt; getVertices(); public V getVertex(int index); public int getIndex(V v); public java.util.List&lt;Integer&gt; getNeighbors(int index); public int getDegree(int v); public void printEdges(); public void clear(); public boolean addVertex(V vertex); public boolean addEdge(int u, int v); public AbstractGraph&lt;V&gt;.Tree dfs(int v); public AbstractGraph&lt;V&gt;.Tree bfs(int v);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270import java.util.*;public abstract class AbstractGraph&lt;V&gt; implements Graph&lt;V&gt; &#123; protected List&lt;V&gt; vertices = new ArrayList&lt;&gt;(); protected List&lt;List&lt;Edge&gt;&gt; neighbors = new ArrayList&lt;&gt;(); protected AbstractGraph() &#123; &#125; protected AbstractGraph(V[] vertices, int[][] edges) &#123; for (int i = 0; i &lt; vertices.length; i++) addVertex(vertices[i]); createAdjacencyLists(edges, vertices.length); &#125; protected AbstractGraph(List&lt;V&gt; vertices, List&lt;Edge&gt; edges) &#123; for (int i = 0; i &lt; vertices.size(); i++) addVertex(vertices.get(i)); createAdjacencyLists(edges, vertices.size()); &#125; protected AbstractGraph(List&lt;Edge&gt; edges, int numberOfVertices) &#123; for (int i = 0; i &lt; numberOfVertices; i++) addVertex((V)(new Integer(i))); createAdjacencyLists(edges, numberOfVertices); &#125; protected AbstractGraph(int[][] edges, int numberOfVertices) &#123; for (int i = 0; i &lt; numberOfVertices; i++) addVertex((V)(new Integer(i))); // vertices is &#123;0, 1, ...&#125; createAdjacencyLists(edges, numberOfVertices); &#125; private void createAdjacencyLists( int[][] edges, int numberOfVertices) &#123; for (int i = 0; i &lt; edges.length; i++) &#123; addEdge(edges[i][0], edges[i][1]); &#125; &#125; private void createAdjacencyLists( List&lt;Edge&gt; edges, int numberOfVertices) &#123; for (Edge edge: edges) &#123; addEdge(edge.u, edge.v); &#125; &#125; @Override public int getSize() &#123; return vertices.size(); &#125; @Override public List&lt;V&gt; getVertices() &#123; return vertices; &#125; @Override public V getVertex(int index) &#123; return vertices.get(index); &#125; @Override public int getIndex(V v) &#123; return vertices.indexOf(v); &#125; @Override public List&lt;Integer&gt; getNeighbors(int index) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (Edge e: neighbors.get(index)) result.add(e.v); return result; &#125; @Override public int getDegree(int v) &#123; return neighbors.get(v).size(); &#125; @Override public void printEdges() &#123; for (int u = 0; u &lt; neighbors.size(); u++) &#123; System.out.print(getVertex(u) + \" (\" + u + \"): \"); for (Edge e: neighbors.get(u)) &#123; System.out.print(\"(\" + getVertex(e.u) + \", \" + getVertex(e.v) + \") \"); &#125; System.out.println(); &#125; &#125; @Override public void clear() &#123; vertices.clear(); neighbors.clear(); &#125; @Override public boolean addVertex(V vertex) &#123; if (!vertices.contains(vertex)) &#123; vertices.add(vertex); neighbors.add(new ArrayList&lt;Edge&gt;()); return true; &#125; else &#123; return false; &#125; &#125; protected boolean addEdge(Edge e) &#123; if (e.u &lt; 0 || e.u &gt; getSize() - 1) throw new IllegalArgumentException(\"No such index: \" + e.u); if (e.v &lt; 0 || e.v &gt; getSize() - 1) throw new IllegalArgumentException(\"No such index: \" + e.v); if (!neighbors.get(e.u).contains(e)) &#123; neighbors.get(e.u).add(e); return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean addEdge(int u, int v) &#123; return addEdge(new Edge(u, v)); &#125; public static class Edge &#123; public int u; public int v; public Edge(int u, int v) &#123; this.u = u; this.v = v; &#125; public boolean equals(Object o) &#123; return u == ((Edge)o).u &amp;&amp; v == ((Edge)o).v; &#125; &#125; @Override public Tree dfs(int v) &#123; List&lt;Integer&gt; searchOrder = new ArrayList&lt;&gt;(); int[] parent = new int[vertices.size()]; for (int i = 0; i &lt; parent.length; i++) parent[i] = -1; boolean[] isVisited = new boolean[vertices.size()]; dfs(v, parent, searchOrder, isVisited); return new Tree(v, parent, searchOrder); &#125; private void dfs(int u, int[] parent, List&lt;Integer&gt; searchOrder, boolean[] isVisited) &#123; searchOrder.add(u); isVisited[u] = true; for (Edge e : neighbors.get(u)) &#123; if (!isVisited[e.v]) &#123; parent[e.v] = u; dfs(e.v, parent, searchOrder, isVisited); &#125; &#125; &#125; @Override public Tree bfs(int v) &#123; List&lt;Integer&gt; searchOrder = new ArrayList&lt;&gt;(); int[] parent = new int[vertices.size()]; for (int i = 0; i &lt; parent.length; i++) parent[i] = -1; java.util.LinkedList&lt;Integer&gt; queue = new java.util.LinkedList&lt;&gt;(); boolean[] isVisited = new boolean[vertices.size()]; queue.offer(v); isVisited[v] = true; while (!queue.isEmpty()) &#123; int u = queue.poll(); searchOrder.add(u); for (Edge e: neighbors.get(u)) &#123; if (!isVisited[e.v]) &#123; queue.offer(e.v); parent[e.v] = u; isVisited[e.v] = true; &#125; &#125; &#125; return new Tree(v, parent, searchOrder); &#125; public class Tree &#123; private int root; private int[] parent; private List&lt;Integer&gt; searchOrder; public Tree(int root, int[] parent, List&lt;Integer&gt; searchOrder) &#123; this.root = root; this.parent = parent; this.searchOrder = searchOrder; &#125; public int getRoot() &#123; return root; &#125; public int getParent(int v) &#123; return parent[v]; &#125; public List&lt;Integer&gt; getSearchOrder() &#123; return searchOrder; &#125; public int getNumberOfVerticesFound() &#123; return searchOrder.size(); &#125; public List&lt;V&gt; getPath(int index) &#123; ArrayList&lt;V&gt; path = new ArrayList&lt;&gt;(); do &#123; path.add(vertices.get(index)); index = parent[index]; &#125; while (index != -1); return path; &#125; public void printPath(int index) &#123; List&lt;V&gt; path = getPath(index); System.out.print(\"A path from \" + vertices.get(root) + \" to \" + vertices.get(index) + \": \"); for (int i = path.size() - 1; i &gt;= 0; i--) System.out.print(path.get(i) + \" \"); &#125; public void printTree() &#123; System.out.println(\"Root is: \" + vertices.get(root)); System.out.print(\"Edges: \"); for (int i = 0; i &lt; parent.length; i++) &#123; if (parent[i] != -1) &#123; System.out.print(\"(\" + vertices.get(parent[i]) + \", \" + vertices.get(i) + \") \"); &#125; &#125; System.out.println(); &#125; &#125;&#125; 123456789101112131415161718192021import java.util.*;public class UnweightedGraph&lt;V&gt; extends AbstractGraph&lt;V&gt; &#123; public UnweightedGraph() &#123; &#125; public UnweightedGraph(V[] vertices, int[][] edges) &#123; super(vertices, edges); &#125; public UnweightedGraph(List&lt;V&gt; vertices, List&lt;Edge&gt; edges) &#123; super(vertices, edges); &#125; public UnweightedGraph(List&lt;Edge&gt; edges, int numberOfVertices) &#123; super(edges, numberOfVertices); &#125; public UnweightedGraph(int[][] edges, int numberOfVertices) &#123; super(edges, numberOfVertices); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://chankin.tech/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://chankin.tech/tags/算法/"}]},{"title":"AVL树的简单实现","slug":"AVL树的简单实现","date":"2018-10-01T14:15:16.000Z","updated":"2018-10-01T14:37:06.360Z","comments":true,"path":"2018/10/01/AVL树的简单实现/","link":"","permalink":"http://chankin.tech/2018/10/01/AVL树的简单实现/","excerpt":"","text":"AVL树是一种自平衡的二叉搜索树（BST），两者之间的区别在于AVL树的左右子树高度之间的差异(平和因子)不能超过1。(树的高度约定为：空结点（空子树）的高度为-1，叶子结点的高度为0)高度和深度有区别,详细了解请看下一下链接 AVL的详细定义:java数据结构与算法之平衡二叉树(AVL树)的设计与实现(其实现和以下代码有点区别,但本质是一样的通过旋转来实现平衡) 实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207public class AVLTree&lt;T extends Comparable&lt;T&gt;&gt;&#123; class AVLNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; public AVLNode&lt;T&gt; left; public AVLNode&lt;T&gt; right; public T data; public int height; public AVLNode(AVLNode&lt;T&gt; left, AVLNode&lt;T&gt; right, T data)&#123; this.left = left; this.right = right; this.data = data; this.height = 0; &#125; &#125; public AVLNode&lt;T&gt; root; public AVLTree() &#123; root = null; &#125; /* * @param x 失衡点 * @ return w 根节点 * */ private AVLNode&lt;T&gt; leftRotation(AVLNode&lt;T&gt; x)&#123; AVLNode&lt;T&gt; w = x.left; x.left = w.right; w.right = x; w.height = Math.max(height(w.left), height(w.right))+ 1; x.height = Math.max(height(x.left), x.height)+ 1; return w; &#125; private AVLNode&lt;T&gt; rightRotation(AVLNode&lt;T&gt; w)&#123; AVLNode&lt;T&gt; x = w.right; w.right = x.left; x.left = w; w.height = Math.max(height(w.left), height(w.right))+ 1; x.height = Math.max(height(x.left), height(x.right))+ 1; return x; &#125; private AVLNode&lt;T&gt; leftRightRotation(AVLNode&lt;T&gt; x)&#123; x.left = rightRotation(x.left); return leftRotation(x); &#125; private AVLNode&lt;T&gt; rightLeftRotation(AVLNode&lt;T&gt; x)&#123; x.right = leftRotation(x.right); return rightRotation(x); &#125; public void insert(T data)&#123; if(root == null) &#123; root = new AVLNode&lt;T&gt;(null,null,data); if (data == null) &#123; throw new RuntimeException(\"data can\\'t be null\"); &#125; &#125; root = insert(root,data);//返回根节点 &#125; private AVLNode&lt;T&gt; insert(AVLNode&lt;T&gt; node, T data)&#123;// node 为根节点 if (node == null) &#123; // 新建节点 node = new AVLNode&lt;T&gt;(null,null,data); if (node == null) &#123; System.out.println(\"ERROR: create avltree node failed!\"); return null; &#125; &#125; if(data.compareTo(node.data) &lt; 0)&#123; node.left = insert(node.left, data); if(height(node.left) - height(node.right) == 2)&#123; if(data.compareTo(node.left.data) &lt; 0)&#123; node = leftRotation(node); &#125;else&#123; node = leftRightRotation(node); &#125; &#125; &#125;else if( data.compareTo(node.data) &gt; 0 )&#123; node.right = insert(node.right, data); if(height(node.right) - height(node.left) == 2)&#123; if(data.compareTo(node.right.data) &gt; 0)&#123; node = rightRotation(node); &#125;else&#123; node = rightLeftRotation(node); &#125; &#125; &#125; else &#123; node.height =Math.max(height(node.left), height(node.right)) + 1; &#125; return node; &#125; private int height(AVLNode&lt;T&gt; tree) &#123; if (tree != null) return tree.height; return 0; &#125; /* * 删除操作 * @param data * @param node * @param return */ public AVLNode&lt;T&gt; remove(T data)&#123; if(data == null)&#123; throw new RuntimeException(\"data can't be null\"); &#125; return root = remove(root, data); &#125; private AVLNode&lt;T&gt; remove(AVLNode&lt;T&gt; node, T data)&#123; if( node == null) return null; if( data.compareTo(node.data) &gt; 0) &#123; return remove(node.right, data); &#125;else if(data.compareTo(node.data) &lt; 0)&#123; return remove(node.left, data); &#125; if (node.left == null || node.right == null) &#123; if ((node.left == null) &amp;&amp; (node.right == null)) &#123; node = null; &#125; else if ((node.left != null) &amp;&amp; (node.right == null)) &#123; node = node.left; if(node.height - node.height == 2) &#123; if (data.compareTo(node.left.data) &lt; 0) &#123; node = leftRotation(node); &#125; else &#123; node = leftRightRotation(node); &#125; &#125; &#125; else if ((node.left == null) &amp;&amp; (node.right != null)) &#123; node = node.right; if(node.right.height - node.left.height == 2)&#123; if(data.compareTo(node.data) &lt; 0)&#123; node = rightLeftRotation(node); &#125;else&#123; node = rightRotation(node); &#125; &#125; &#125; &#125; else &#123; if (node.left.height &gt;node.right.height) &#123; node.data = findMax(); node.left = remove(node.left, node.data); &#125; else &#123; node.data = findMin(); node.right = remove(node.right, node.data); &#125; &#125; node.height = Math.max(node.left.height, node.right.height); return node; &#125; public T findMin() &#123; AVLNode&lt;T&gt; node = findMin(root); if(node != null) return node.data; return null; &#125; public T findMax()&#123; AVLNode&lt;T&gt; node = findMax(root); if(node != null) return node.data; return null; &#125; /* * 查找最小值结点 * @param node * @return */ private AVLNode&lt;T&gt; findMin(AVLNode&lt;T&gt; node)&#123; if (node == null)//结束条件 return null; while (node.left !=null)//如果没有左结点,那么t就是最小的 node = node.left; return node; &#125; /* * 查找最小值结点 * @param node * @return */ private AVLNode&lt;T&gt; findMax(AVLNode&lt;T&gt; node)&#123; if (node == null)//结束条件 return null; while (node.right !=null)//如果没有左结点,那么t就是最小的 node = node.right; return node; &#125;&#125;class AVLTreeTest&#123; public static void main(String[] args)&#123; AVLTree&lt;Integer&gt; avlTree = new AVLTree&lt;&gt;(); for (int i = 1; i &lt;18 ; i++) &#123; avlTree.insert(i); System.out.println(i); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://chankin.tech/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chankin.tech/tags/数据结构/"}]},{"title":"二叉树的简单实现","slug":"二叉树的简单实现","date":"2018-10-01T13:54:03.000Z","updated":"2018-10-01T14:08:41.572Z","comments":true,"path":"2018/10/01/二叉树的简单实现/","link":"","permalink":"http://chankin.tech/2018/10/01/二叉树的简单实现/","excerpt":"","text":"二叉树的实现,其查找、插入、删除等操作 关键在于当前节点 和根节点进行比较,小于则于左子树比较,大于则于右子树比较 ,然后根据递归实现。 以前不知道什么时候实现的,好像没什么问题 ,就传上来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class BinaryTree&lt;K extends Comparable&lt;K&gt;,V&gt; &#123; private Node root; private int foot = 0; private int count; private Object[] array; public static class Entry&lt;K extends Comparable&lt;K&gt;, V&gt; implements Comparable&lt;K&gt; &#123; private K key; private V value; public Entry(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return this.key; &#125; public V getValue() &#123; return this.value; &#125; public int compareTo(K o) &#123; return this.key.compareTo(o); &#125; &#125; private class Node &#123; private Node left; private Node right; private Node parent; private BinaryTree.Entry&lt;K, V&gt; data; public V getNode(K key) &#123; if (key.compareTo(this.data.key) == 0) &#123; return this.data.value; &#125; else if (key.compareTo(this.data.key) &lt; 0) &#123; if (this.left != null) &#123; return this.left.getNode(key); &#125; else &#123; return null; &#125; &#125; else &#123; if (this.right != null) &#123; return this.right.getNode(key); &#125; else &#123; return null; &#125; &#125; &#125; public Node(BinaryTree.Entry&lt;K, V&gt; data) &#123; this.data = data; &#125; public boolean containsNode(BinaryTree.Entry&lt;K, V&gt; data) &#123; if (data.key.compareTo(this.data.key) == 0) &#123; return true; &#125; else if (data.key.compareTo(this.data.key) &lt; 0) &#123; return this.left.containsNode(data); &#125; else &#123; return this.right.containsNode(data); &#125; &#125; public void addNode(Node newNode) &#123; if (newNode.data.key.compareTo(this.data.key) == 0) &#123; new Exception(\"该数值已经存在\"); &#125; else if (newNode.data.key.compareTo(this.data.key) &lt; 0) &#123; if (this.left == null) &#123; this.left = newNode; newNode.parent = this; &#125; else &#123; this.left.addNode(newNode); &#125; &#125; else &#123; if (this.right == null) &#123; this.right = newNode; newNode.parent = this; &#125; else &#123; this.right.addNode(newNode); &#125; &#125; &#125; public void toArrayNode() &#123; if (this.left != null) &#123; this.left.toArrayNode(); &#125; BinaryTree.this.array[BinaryTree.this.foot++] = this.data; if (this.right != null) &#123; this.right.toArrayNode(); &#125; &#125; &#125; public Object[] toArray() &#123; if (this.count == 0) &#123; return null; &#125; this.array = new Object[this.count]; this.foot = 0; this.root.toArrayNode(); return this.array; &#125; public boolean contrains(K key) &#123; if (this.count == 0) &#123; return false; &#125; return this.root.containsNode(new BinaryTree.Entry(key, null)); &#125; public void add(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException(\"faksdlfj;lk\"); &#125; Node newNode = new Node(new BinaryTree.Entry(key, value)); if (this.root == null) &#123; this.root = newNode; &#125; else &#123; this.root.addNode(newNode); &#125; this.count++; &#125; public V getKey(K key)&#123; if(this.count== 0 || key == null)&#123; return null; &#125; return this.root.getNode(key); &#125;&#125;class Person &#123; public int age; public String name; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public String toString()&#123; return \"特性: \" + this.name + \" 值 = \" + this.age + \"\\n\"; &#125;&#125;class Ts&#123; public static void main(String[] args)&#123; BinaryTree&lt;Integer,Person&gt; s = new BinaryTree&lt;Integer,Person&gt;(); s.add(1,new Person(\"一致性\",11)); s.add(2,new Person(\"原子性\",22)); s.add(3,new Person(\"隔离性\",333)); s.add(4,new Person(\"完整性\",444)); s.add(5,new Person(\"持久性\",555)); Object result[] = s.toArray(); for(Object ojb: result)&#123; BinaryTree.Entry&lt;Integer,Person&gt; entry = (BinaryTree.Entry&lt;Integer,Person&gt;)ojb; System.out.println(entry.getKey() + \"===\" + entry.getValue()); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://chankin.tech/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chankin.tech/tags/数据结构/"}]},{"title":"剑指Offer--根据前序遍历和中序遍历重建二叉树","slug":"剑指Offer-根据前序遍历和中序遍历重建二叉树","date":"2018-10-01T12:00:56.000Z","updated":"2018-10-01T13:54:26.992Z","comments":true,"path":"2018/10/01/剑指Offer-根据前序遍历和中序遍历重建二叉树/","link":"","permalink":"http://chankin.tech/2018/10/01/剑指Offer-根据前序遍历和中序遍历重建二叉树/","excerpt":"","text":"题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{1,2,4,7,3,5,6,8}，则重建二叉树并返回。 二叉树前序遍历Preorder Traversal: 根-左-右{1,2,4,7,3,5,6,8} 二叉树中序遍历Inorder Traversal: 左-根-右{1,2,4,7,3,5,6,8} 可以判断出前序遍历第一点一定是根节点,然后在根据 利用while循环找出中序遍历的根节点的index; 根据根节点判断出中序遍历左边部分是左子树,右边是右子树; 根据中序遍历了第一点和根节点判断偏移量index-startIn(循环第一次是index为3); 中序遍历根节点左边第一点就是左子树最后一个节点(最大点)index-startIn +startPre (前序第一点加偏移量); 前序遍历左子树最后一个节点的后一点 index-startIn+startPre+1就是右子树第一点,index+1中序遍历右子树的第一点; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** jdk 1.8 * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre == null || in == null)&#123; return null; &#125; TreeNode root = reConstruct(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; /** * * @param pre 前序遍历 * @param startPre 前序遍历的开始点 * @param endPre 前序遍历的结束点 * @param in 中序遍历 * @param startIn 中序遍历的开始点 * @param endIn 中序遍历的结束位点 * @return root 树的根节点 */ private TreeNode reConstruct(int[] pre,int startPre,int endPre,int[] in,int startIn,int endIn )&#123; if(startPre &gt; endPre||startIn &gt; endIn)&#123; return null; &#125; TreeNode root = new TreeNode(pre[startPre]);//创建当前节点 for(int index=startIn;index&lt;=endIn;index++) if(in[index]==pre[startPre])&#123; //找出中序遍历当前节点的位置 //递归实现遍历左子树 root.left=reConstruct(pre,startPre+1,index-startIn +startPre,in,startIn,index-1); //递归实现遍历右子树 root.right=reConstruct(pre,index-startIn+startPre + 1,endPre,in,index+1,endIn); &#125; return root; &#125;&#125; Ps:真的有点难,用递归完全想不到,就是题做得太少了 参考： https://www.cnblogs.com/zywu/p/5758917.html https://segmentfault.com/a/1190000012207144","categories":[{"name":"算法","slug":"算法","permalink":"http://chankin.tech/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://chankin.tech/categories/算法/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chankin.tech/tags/数据结构/"}]},{"title":"Hexo-theme-indigo解决置顶问题","slug":"Hexo-theme-indigo解决置顶问题","date":"2018-09-28T15:51:29.000Z","updated":"2018-09-28T16:13:26.740Z","comments":true,"path":"2018/09/28/Hexo-theme-indigo解决置顶问题/","link":"","permalink":"http://chankin.tech/2018/09/28/Hexo-theme-indigo解决置顶问题/","excerpt":"","text":"将node_modules/hexo-generator-index/lib/generator.js的文件内容替换成一下内容 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在新建的md日志文件种加入top初始化命令比如说： 12345title: Hexo置顶文章date: 2016-11-11 23:26:22tags:categories: Hexotop: 0 #0或者1 当top的值取0的时候，表示默认排序，即是按照时间顺序来排序。 当top的值取1到无为置顶文件限大的时候，值最高的md文件即是置顶文章","categories":[],"tags":[]},{"title":"sql语句练习51题","slug":"sql语句练习51题","date":"2018-09-28T13:13:45.000Z","updated":"2018-09-28T13:36:43.874Z","comments":true,"path":"2018/09/28/sql语句练习51题/","link":"","permalink":"http://chankin.tech/2018/09/28/sql语句练习51题/","excerpt":"","text":"&emsp;&emsp; 习题来源于网络，难度会稍高, sql语句是一部分自己写的，一部分是参考的(前23题当时没保存,直接拷贝原博)。其中有很多大神的牛逼写法,也有我自己比较差劲的写法。 源自: sql语句练习50题(Mysql版)CSDN博客 表名和字段 学生表 : Student(s_id,s_name,s_birth,s_sex) – –学生编号,学生姓名, 出生年月,学生性别 课程表 :Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号 教师表:Teacher(t_id,t_name) – –教师编号,教师姓名 成绩表Score(s_id,c_id,s_score) – – 学生编号,课程编号,分数 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--建表--学生表CREATE TABLE `Student`(`s_id` VARCHAR(20),`s_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`s_birth` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`s_sex` VARCHAR(10) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY(`s_id`));--课程表CREATE TABLE `Course`(`c_id` VARCHAR(20),`c_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`t_id` VARCHAR(20) NOT NULL,PRIMARY KEY(`c_id`));--教师表CREATE TABLE `Teacher`(`t_id` VARCHAR(20),`t_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY(`t_id`));--成绩表CREATE TABLE `Score`(`s_id` VARCHAR(20),`c_id` VARCHAR(20),`s_score` INT(3),PRIMARY KEY(`s_id`,`c_id`));--插入学生表测试数据insert into Student values(&apos;01&apos; , &apos;赵雷&apos; , &apos;1990-01-01&apos; , &apos;男&apos;);insert into Student values(&apos;02&apos; , &apos;钱电&apos; , &apos;1990-12-21&apos; , &apos;男&apos;);insert into Student values(&apos;03&apos; , &apos;孙风&apos; , &apos;1990-05-20&apos; , &apos;男&apos;);insert into Student values(&apos;04&apos; , &apos;李云&apos; , &apos;1990-08-06&apos; , &apos;男&apos;);insert into Student values(&apos;05&apos; , &apos;周梅&apos; , &apos;1991-12-01&apos; , &apos;女&apos;);insert into Student values(&apos;06&apos; , &apos;吴兰&apos; , &apos;1992-03-01&apos; , &apos;女&apos;);insert into Student values(&apos;07&apos; , &apos;郑竹&apos; , &apos;1989-07-01&apos; , &apos;女&apos;);insert into Student values(&apos;08&apos; , &apos;王菊&apos; , &apos;1990-01-20&apos; , &apos;女&apos;);--课程表测试数据insert into Course values(&apos;01&apos; , &apos;语文&apos; , &apos;02&apos;);insert into Course values(&apos;02&apos; , &apos;数学&apos; , &apos;01&apos;);insert into Course values(&apos;03&apos; , &apos;英语&apos; , &apos;03&apos;);--教师表测试数据insert into Teacher values(&apos;01&apos; , &apos;张三&apos;);insert into Teacher values(&apos;02&apos; , &apos;李四&apos;);insert into Teacher values(&apos;03&apos; , &apos;王五&apos;);--成绩表测试数据insert into Score values(&apos;01&apos; , &apos;01&apos; , 80);insert into Score values(&apos;01&apos; , &apos;02&apos; , 90);insert into Score values(&apos;01&apos; , &apos;03&apos; , 99);insert into Score values(&apos;02&apos; , &apos;01&apos; , 70);insert into Score values(&apos;02&apos; , &apos;02&apos; , 60);insert into Score values(&apos;02&apos; , &apos;03&apos; , 80);insert into Score values(&apos;03&apos; , &apos;01&apos; , 80);insert into Score values(&apos;03&apos; , &apos;02&apos; , 80);insert into Score values(&apos;03&apos; , &apos;03&apos; , 80);insert into Score values(&apos;04&apos; , &apos;01&apos; , 50);insert into Score values(&apos;04&apos; , &apos;02&apos; , 30);insert into Score values(&apos;04&apos; , &apos;03&apos; , 20);insert into Score values(&apos;05&apos; , &apos;01&apos; , 76);insert into Score values(&apos;05&apos; , &apos;02&apos; , 87);insert into Score values(&apos;06&apos; , &apos;01&apos; , 31);insert into Score values(&apos;06&apos; , &apos;03&apos; , 34);insert into Score values(&apos;07&apos; , &apos;02&apos; , 89);insert into Score values(&apos;07&apos; , &apos;03&apos; , 98); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381-- * 查询每门课程选修的同学信息SELECT a.*, b.c_id FROM student a RIGHT JOIN score b ON a.s_id = b.s_id WHERE b.c_id in( SELECT c.c_id FROM score c GROUP BY c.c_id HAVING count(*)) order by c_id;-- 1、查询&quot;01&quot;课程比&quot;02&quot;课程成绩高的学生的信息及课程分数 select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a join score b on a.s_id=b.s_id and b.c_id=&apos;01&apos; left join score c on a.s_id=c.s_id and c.c_id=&apos;02&apos; or c.c_id = NULL where b.s_score&gt;c.s_score-- 2、查询&quot;01&quot;课程比&quot;02&quot;课程成绩低的学生的信息及课程分数select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a left join score b on a.s_id=b.s_id and b.c_id=&apos;01&apos; or b.c_id=NULL join score c on a.s_id=c.s_id and c.c_id=&apos;02&apos; where b.s_score&lt;c.s_score-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b join score a on b.s_id = a.s_id GROUP BY b.s_id,b.s_name HAVING ROUND(AVG(a.s_score),2)&gt;=60;-- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩 -- (包括有成绩的和无成绩的)select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b left join score a on b.s_id = a.s_id GROUP BY b.s_id,b.s_name HAVING ROUND(AVG(a.s_score),2)&lt;60 unionselect a.s_id,a.s_name,0 as avg_score from student a where a.s_id not in ( select distinct s_id from score);-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩select a.s_id,a.s_name,count(b.c_id) as sum_course,sum(b.s_score) as sum_score from student a left join score b on a.s_id=b.s_id GROUP BY a.s_id,a.s_name;-- 6、查询&quot;李&quot;姓老师的数量 select count(t_id) from teacher where t_name like &apos;李%&apos;;-- 7、查询学过&quot;张三&quot;老师授课的同学的信息 select a.* from student a join score b on a.s_id=b.s_id where b.c_id in( select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;));-- 8、查询没学过&quot;张三&quot;老师授课的同学的信息 select * from student c where c.s_id not in( select a.s_id from student a join score b on a.s_id=b.s_id where b.c_id in( select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;)))-- 9、查询学过编号为&quot;01&quot;并且也学过编号为&quot;02&quot;的课程的同学的信息select a.* from student a,score b,score c where a.s_id = b.s_id and a.s_id = c.s_id and b.c_id=&apos;01&apos; and c.c_id=&apos;02&apos;;-- 10、查询学过编号为&quot;01&quot;但是没有学过编号为&quot;02&quot;的课程的同学的信息select a.* from student a where a.s_id in (select s_id from score where c_id=&apos;01&apos; ) and a.s_id not in(select s_id from score where c_id=&apos;02&apos;)-- 11、查询没有学全所有课程的同学的信息 --第一种 select s.* from student s where s.s_id in( select s_id from score where s_id not in( select a.s_id from score a join score b on a.s_id = b.s_id and b.c_id=&apos;02&apos; join score c on a.s_id = c.s_id and c.c_id=&apos;03&apos; where a.c_id=&apos;01&apos;)) --第二种 SELECT a.* FROM student a RIGHT JOIN (SELECT s_id, count(*) FROM score GROUP BY s_id HAVING count(c_id) &lt; (SELECT count(*) FROM course)) AS b ON a.s_id = b.s_id -- 12、查询至少有一门课与学号为&quot;01&quot;的同学所学相同的同学的信息 select * from student where s_id in( select distinct a.s_id from score a where a.c_id in(select a.c_id from score a where a.s_id=&apos;01&apos;) )-- 13、查询和&quot;01&quot;号的同学学习的课程完全相同的其他同学的信息 select a.* from student a where a.s_id in( select distinct s_id from score where s_id!=&apos;01&apos; and c_id in(select c_id from score where s_id=&apos;01&apos;) group by s_id having count(1)=(select count(1) from score where s_id=&apos;01&apos;));-- 14、查询没学过&quot;张三&quot;老师讲授的任一门课程的学生姓名 select a.s_name from student a where a.s_id not in ( select s_id from score where c_id = (select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;)) group by s_id);-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 select a.s_id,a.s_name,ROUND(AVG(b.s_score)) from student a left join score b on a.s_id = b.s_id where a.s_id in( select s_id from score where s_score&lt;60 GROUP BY s_id having count(1)&gt;=2) GROUP BY a.s_id,a.s_name-- 16、检索&quot;01&quot;课程分数小于60，按分数降序排列的学生信息select a.*,b.c_id,b.s_score from student a,score b where a.s_id = b.s_id and b.c_id=&apos;01&apos; and b.s_score&lt;60 ORDER BY b.s_score DESC;-- 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩select a.s_id,(select s_score from score where s_id=a.s_id and c_id=&apos;01&apos;) as 语文, (select s_score from score where s_id=a.s_id and c_id=&apos;02&apos;) as 数学, (select s_score from score where s_id=a.s_id and c_id=&apos;03&apos;) as 英语, round(avg(s_score),2) as 平均分 from score a GROUP BY a.s_id ORDER BY 平均分 DESC;-- 18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率--及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90select a.c_id,b.c_name,MAX(s_score),MIN(s_score),ROUND(AVG(s_score),2), ROUND(100*(SUM(case when a.s_score&gt;=60 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 及格率, ROUND(100*(SUM(case when a.s_score&gt;=70 and a.s_score&lt;=80 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 中等率, ROUND(100*(SUM(case when a.s_score&gt;=80 and a.s_score&lt;=90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 优良率, ROUND(100*(SUM(case when a.s_score&gt;=90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 优秀率 from score a left join course b on a.c_id = b.c_id GROUP BY a.c_id,b.c_name-- 19、按各科成绩进行排序，并显示排名(实现不完全)-- mysql没有rank函数 select a.s_id,a.c_id, @i:=@i +1 as i保留排名, @k:=(case when @score=a.s_score then @k else @i end) as rank不保留排名, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;01&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s union select a.s_id,a.c_id, @i:=@i +1 as i, @k:=(case when @score=a.s_score then @k else @i end) as rank, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;02&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s union select a.s_id,a.c_id, @i:=@i +1 as i, @k:=(case when @score=a.s_score then @k else @i end) as rank, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;03&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s-- 20、查询学生的总成绩并进行排名 select a.s_id, @i:=@i+1 as i, @k:=(case when @score=a.sum_score then @k else @i end) as rank, @score:=a.sum_score as score from (select s_id,SUM(s_score) as sum_score from score GROUP BY s_id ORDER BY sum_score DESC)a, (select @k:=0,@i:=0,@score:=0)s-- 21、查询不同老师所教不同课程平均分从高到低显示 select a.t_id,c.t_name,a.c_id,ROUND(avg(s_score),2) as avg_score from course a left join score b on a.c_id=b.c_id left join teacher c on a.t_id=c.t_id GROUP BY a.c_id,a.t_id,c.t_name ORDER BY avg_score DESC;-- 22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩 select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@i:=@i+1 as 排名 from score a,(select @i:=0)s where a.c_id=&apos;01&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@j:=@j+1 as 排名 from score a,(select @j:=0)s where a.c_id=&apos;02&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@k:=@k+1 as 排名 from score a,(select @k:=0)s where a.c_id=&apos;03&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3; -- 23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比 select distinct f.c_name,a.c_id,b.`85-100`,b.百分比,c.`70-85`,c.百分比,d.`60-70`,d.百分比,e.`0-60`,e.百分比 from score a LEFT JOIN (select c_id,sum(case when s_score &gt; 85 and s_score &lt;= 100 then 1 else 0 end) as `85-100`,100*(sum(case when s_score &gt; 85 and s_score &lt;= 100 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) b on a.c_id = b.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 70 and s_score &lt;= 85 then 1 else 0 end) as `70-85`,100*(sum(case when s_score &gt; 70 and s_score &lt;= 85 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) c on a.c_id = c.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 60 and s_score &lt;= 70 then 1 else 0 end) as `60-70`,100*(sum(case when s_score &gt; 60 and s_score &lt;= 70 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) d on a.c_id = d.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 0 and s_score &lt;= 60 then 1 else 0 end) as `0-60`,100*(sum(case when s_score &gt; 0 and s_score &lt;= 60 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) e on a.c_id = e.c_id left join course f on a.c_id = f.c_id-- 24、查询学生平均成绩及其名次 SELECT a.s_id , @i :=@i+ 1 AS 名次 , @k := avg_s AS 平均分 FROM (SELECT s_id, avg(s_score) AS avg_s FROM score GROUP BY s_id) a, (SELECT @k := 0 ,@i := 0) b order by 平均分 desc -- 25、查询各科成绩前三名的记录 -- 1.选出b表比a表成绩大的所有组 -- 2.选出比当前id成绩大的 小于三个的 SELECT DISTINCT a.s_id, a.c_id,a.s_score FROM score a LEFT JOIN score b ON a.c_id = b.c_id AND a.s_score &lt; b.s_score GROUP BY a.s_id, a.c_id, a.s_score HAVING COUNT(a.s_id) &lt; 3 ORDER BY a.c_id,a.s_score DESC-- 26、查询每门课程被选修的学生数 select c_id,count(c_id) from score group by c_id -- 27、查询出只有两门课程的全部学生的学号和姓名 select s_id,s_name from student where s_id in (select s_id from score group by s_id having count(c_id) = 2)-- 28、查询男生、女生人数 select s_sex,COUNT(s_sex) as 人数 from student GROUP BY s_sex-- 29、查询名字中含有&quot;风&quot;字的学生信息 select * from student where s_name like &apos;%风%&apos;-- 30、查询同名同性学生名单，并统计同名人数 select a.s_name,a.s_sex,count(*) from student a JOIN student b on a.s_id !=b.s_id and a.s_name = b.s_name and a.s_sex = b.s_sex GROUP BY a.s_name,a.s_sex-- 31、查询1990年出生的学生名单 select s_name from student where s_birth like &apos;1990%&apos;-- 32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 select c_id,avg(s_score) as 平均成绩 from score group by c_id order by 平均成绩 desc,c_id asc-- 33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩 SELECT A.S_ID,A.S_NAME,AVG(B.S_SCORE) AS 平均成绩 FROM STUDENT A LEFT JOIN SCORE B ON A.S_ID =B.S_ID GROUP BY S_ID HAVING AVG(B.S_SCORE)&gt;=85-- 34、查询课程名称为&quot;数学&quot;，且分数低于60的学生姓名和分数 select a.s_name,b.s_score from student a left join score b on a.s_id = b.s_id where b.s_score &lt; 60 group by a.s_id -- 可能会出现 [Err] 1055 的错误 只需在my.ini中[mysqld]加入sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;-- 35、查询所有学生的课程及分数情况 --第一种不直观 SELECT a.s_id,b.c_id,a.s_score FROM score a LEFT JOIN course b on a.c_id =b.c_id select a.s_id,a.s_name, SUM(case c.c_name when &apos;语文&apos; then b.s_score else 0 end) as &apos;语文&apos;, SUM(case c.c_name when &apos;数学&apos; then b.s_score else 0 end) as &apos;数学&apos;, SUM(case c.c_name when &apos;英语&apos; then b.s_score else 0 end) as &apos;英语&apos;, SUM(b.s_score) as &apos;总分&apos; from student a left join score b on a.s_id = b.s_id left join course c on b.c_id = c.c_id GROUP BY a.s_id,a.s_name -- 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数 select a.s_name,c.c_name,b.s_score from student a left join score b on a.s_id =b.s_id left join course c on b.c_id =c.c_id where b.s_score &gt; 70-- 37、查询不及格的课程 select a.s_id,a.c_id,b.c_name,a.s_score from score a left join course b on a.c_id = b.c_id where a.s_score&lt;60 --38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名 select s_id,s_name from student where s_id in (select s_id from score where c_id =&apos;01&apos; and s_score &gt; 80 ) -- 39、求每门课程的学生人数 select c_id,count(c_id) from score group by c_id-- 40、查询选修&quot;张三&quot;老师所授课程的学生中，成绩最高的学生信息及其成绩 select a.*,b.s_score,b.c_id,c.c_name from student a LEFT JOIN score b on a.s_id = b.s_id LEFT JOIN course c on b.c_id=c.c_id where b.c_id =(select c_id from course c,teacher d where c.t_id=d.t_id and d.t_name=&apos;张三&apos;) and b.s_score = (select MAX(s_score) from score where c_id=(select c_id from course c,teacher d where c.t_id=d.t_id and d.t_name=&apos;张三&apos;))-- 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 --第一种 SELECT * FROM score a WHERE (SELECT count(*) FROM score b WHERE b.c_id = a.c_id AND b.s_score &gt; a.s_score) &lt;= 1 --第二种 select a.s_id,a.c_id,a.s_score from score a where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score&gt;=a.s_score)&lt;=2 ORDER BY a.c_id-- 42、查询每门功成绩最好的前两名 -- 牛逼的写法 select a.s_id,a.c_id,a.s_score from score a where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score&gt;=a.s_score)&lt;=2 ORDER BY a.c_id-- 43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 select c_id,count(*) as total from score GROUP BY c_id HAVING total&gt;5 ORDER BY total,c_id ASC-- 44、检索至少选修两门课程的学生学号 select s_id from score group by s_id having count(s_id) &gt;1-- 45、查询选修了全部课程的学生信息 select * from student where s_id in (select s_id from score group by s_id having count(*) =(select count(*) from course))--46、查询各学生的年龄 -- 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一 select s_birth,(DATE_FORMAT(NOW(),&apos;%Y&apos;)-DATE_FORMAT(s_birth,&apos;%Y&apos;) - (case when DATE_FORMAT(NOW(),&apos;%m%d&apos;)&gt;DATE_FORMAT(s_birth,&apos;%m%d&apos;) then 0 else 1 end)) as age from student;-- 47、查询本周过生日的学生 select * from student where WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))=WEEK(s_birth) select * from student where YEARWEEK(s_birth)=YEARWEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;)) select WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))-- 48、查询下周过生日的学生 select * from student where WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))+1 =WEEK(s_birth)-- 49、查询本月过生日的学生 select * from student where MONTH(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;)) =MONTH(s_birth)-- 50、查询下月过生日的学生 select * from student where MONTH(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))+1 =MONTH(s_birth)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://chankin.tech/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://chankin.tech/tags/Mysql/"}]},{"title":"整理一些学习过的数据结构和算法blog","slug":"整理一些学习过的数据结构和算法blog","date":"2018-09-28T03:39:39.000Z","updated":"2018-09-28T15:59:45.879Z","comments":true,"path":"2018/09/28/整理一些学习过的数据结构和算法blog/","link":"","permalink":"http://chankin.tech/2018/09/28/整理一些学习过的数据结构和算法blog/","excerpt":"","text":"树形结构:二叉查找树 二叉查找树之 Java的实现 二叉搜索树Java实现（查找、插入、删除、遍历） - Michaelwjw - 博客园 AVL树的设计与实现 - CSDN博客 彻底搞懂AVL树 - 简书 AVL树(三)之 Java的实现 - 如果天空不死 - 博客园 红黑树(一)之 原理和算法详细介绍 红黑树(五)之 Java的实现 查找（一）史上最简单清晰的红黑树讲解 - CSDN博客 !最容易懂得红黑树 - CSDN博客 查找（一）史上最简单清晰的红黑树讲解 - CSDN博客 查找树（2-3-4 树） - 匠心十年- 博客园 图的遍历之 深度优先搜索和广度优先搜索 哈夫曼树(三)之 Java详解 从B树、B+树、B*树谈到R 树 Trie树详解及其应用 数据结构与算法中，树一般会应用在哪些方面？为什么？ - 知乎 算法系列:8大排序:冒泡排序 快速排序 直接插入排序 希尔排序 选择排序 堆排序 桶排序 基数排序 其他基础算法:递归之斐波那契数列java的三种写法- CSDN博客 8皇后以及N皇后算法探究，回溯算法的JAVA实现，递归方案 分治归并排序算法——Java实现- CSDN博客 java-贪心算法 【贪心法求解最小生成树之Kruskal算法详细分析】—Greedy Algorithm for MST Prim算法(三)之 Java详解 Dijkstra算法(三)之Java详解- 如果天空不死- 博客园 并发编程:海子大神系列: Java并发编程：进程和线程之由来 Java并发编程：如何创建线程？ Java并发编程：Thread类的使用 Java并发编程：线程间协作的两种方式：wait、notify、notifyAll和Condition Java并发编程：synchronized Java并发编程：Lock Java并发编程：volatile关键字解析 Java并发编程：深入剖析ThreadLocal Java并发编程：同步容器 Java ConcurrentModificationException异常原因和解决方法 Java并发编程：并发容器之ConcurrentHashMap（转载） Java并发编程：并发容器之CopyOnWriteArrayList（转载） Java并发编程：阻塞队列 Java并发编程：线程池的使用 Java并发编程：CountDownLatch、CyclicBarrier和Semaphore Java并发编程：Callable、Future和FutureTask Java并发编程：Timer和TimerTask（转载） skywang大神系列:(一) 基础篇 Java多线程系列–“基础篇”01之 基本概念 Java多线程系列–“基础篇”02之 常用的实现多线程的两种方式 Java多线程系列–“基础篇”03之 Thread中start()和run()的区别 Java多线程系列–“基础篇”04之 synchronized关键字 Java多线程系列–“基础篇”05之 线程等待与唤醒 Java多线程系列–“基础篇”06之 线程让步 Java多线程系列–“基础篇”07之 线程休眠 Java多线程系列–“基础篇”08之 join() Java多线程系列–“基础篇”09之 interrupt()和线程终止方式 Java多线程系列–“基础篇”10之 线程优先级和守护线程 Java多线程系列–“基础篇”11之 生产消费者问题 (二) JUC原子类 Java多线程系列–“JUC原子类”01之 框架 Java多线程系列–“JUC原子类”02之 AtomicLong原子类 Java多线程系列–“JUC原子类”03之 AtomicLongArray原子类 Java多线程系列–“JUC原子类”04之 AtomicReference原子类 Java多线程系列–“JUC原子类”05之 AtomicLongFieldUpdater原子类 (三) JUC锁 Java多线程系列–“JUC锁”01之 框架 Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock Java多线程系列–“JUC锁”03之 公平锁(一) Java多线程系列–“JUC锁”04之 公平锁(二) Java多线程系列–“JUC锁”05之 非公平锁 Java多线程系列–“JUC锁”06之 Condition条件 Java多线程系列–“JUC锁”07之 LockSupport Java多线程系列–“JUC锁”08之 共享锁和ReentrantReadWriteLock Java多线程系列–“JUC锁”09之 CountDownLatch原理和示例 Java多线程系列–“JUC锁”10之 CyclicBarrier原理和示例 Java多线程系列–“JUC锁”11之 Semaphore信号量的原理和示例 (四) JUC集合 Java多线程系列–“JUC集合”01之 框架 Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet Java多线程系列–“JUC集合”04之 ConcurrentHashMap Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap Java多线程系列–“JUC集合”06之 ConcurrentSkipListSet Java多线程系列–“JUC集合”07之 ArrayBlockingQueue Java多线程系列–“JUC集合”08之 LinkedBlockingQueue Java多线程系列–“JUC集合”09之 LinkedBlockingDeque Java多线程系列–“JUC集合”10之 ConcurrentLinkedQueue (五) JUC线程池 Java多线程系列–“JUC线程池”01之 线程池架构 Java多线程系列–“JUC线程池”02之 线程池原理(一) Java多线程系列–“JUC线程池”03之 线程池原理(二) Java多线程系列–“JUC线程池”04之 线程池原理(三) Java多线程系列–“JUC线程池”05之 线程池原理(四) Java多线程系列–“JUC线程池”06之 Callable和Future 附加内容《深入理解Java内存模型》读书总结 深入浅出ThreadLocal - Java综合 - Java - ITeye论坛 ThreadLocal-面试必问深度解析 - 简书 面试集合:Java线程面试题 Top 50 （转载） JAVA多线程和并发基础面试问答（转载） IO/IP HTTP TCP:HTTP2和HTTPS来不来了解一下？ - 掘金 Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码） - CSDN博客 TCP协议详解 - Red_Code - 博客园 基础笔记（三）：网络协议之Tcp、Http - 老真 - 博客园 【NIO引入】BIO、AIO与NIO的区别 - CSDN博客 Java NIO：浅析I/O模型 书籍: 如果有人让你推荐前端技术书，请让他看这个列表 - WEB前端 - 伯乐在线 JAVA程序员必看的15本书-JAVA自学书籍推荐 （转） - CSDN博客 干货 ｜ 推荐五本国外最受欢迎的Spring教程书","categories":[{"name":"算法","slug":"算法","permalink":"http://chankin.tech/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://chankin.tech/categories/算法/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chankin.tech/tags/数据结构/"},{"name":"收藏","slug":"收藏","permalink":"http://chankin.tech/tags/收藏/"},{"name":"算法","slug":"算法","permalink":"http://chankin.tech/tags/算法/"},{"name":"并发","slug":"并发","permalink":"http://chankin.tech/tags/并发/"}]},{"title":"test","slug":"test","date":"2018-09-27T18:10:39.000Z","updated":"2018-09-28T09:47:43.752Z","comments":true,"path":"2018/09/28/test/","link":"","permalink":"http://chankin.tech/2018/09/28/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"解析Tomcat内部结构和请求过程","slug":"解析Tomcat内部结构和请求过程","date":"2018-09-27T16:52:19.000Z","updated":"2018-09-28T09:45:32.076Z","comments":true,"path":"2018/09/28/解析Tomcat内部结构和请求过程/","link":"","permalink":"http://chankin.tech/2018/09/28/解析Tomcat内部结构和请求过程/","excerpt":"","text":"","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://chankin.tech/categories/Tomcat/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://chankin.tech/tags/Tomcat/"}]},{"title":"Typora的简单使用","slug":"Typora的简单使用","date":"2018-09-27T03:00:00.000Z","updated":"2018-09-28T10:23:23.894Z","comments":true,"path":"2018/09/27/Typora的简单使用/","link":"","permalink":"http://chankin.tech/2018/09/27/Typora的简单使用/","excerpt":"","text":"Typora是一款超简洁的markdown编辑器，具有如下特点： 完全免费，目前已支持中文 跨平台，支持windows,mac,linux 支持数学公式输入，图片插入 极其简洁，无多余功能 界面所见即所得 区域元素YAML FONT Matters在文章最上方输入---，按换行键产生，输入内容即可 菜单输入+换行键，产生标题，自动更新 1[toc] + 回车键 段落按换行键建立新的一行可在行尾插入打断线，禁止向后插入 1按换行键建立新的一行&lt;br/&gt; 标题开头#的个数表示，空格+文字。标题有1~6个级别，#表示开始，按换行键结束 123# H1## H2###### H6 引注开头&gt;表示，空格+文字，按换行键换行，双按换行跳出 123&gt; ni&gt;&gt; ni hao ni nini 序列开头* + -，空格+文字，可以创建无序序列，换行键换行，删除键+shift+tab跳出 开头1.，空格+后接文字，可以创建有序序列 1234567* Red+ Green- Blue1. Red2. Green3. Blue 无序序列 你 可选序列开头序列+空格+[ ]+空格+文字，换行键换行，删除键+shift+tab跳出 1234- [ ] a+ [ ] b* [ ] c- [x] completed [x] a [x] b [x] c [x] d 代码块1234​```javapublic class test&#123;&#125;``` 数学块使用MtathJax建立数学公式 开头$$+换行键，产生输入区域， 输入Tex/LaTex格式的数学公式 1234567$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125;\\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\end&#123;vmatrix&#125;$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$ 表格开头| 列名 | 列名 | 换行键，创建一个2*2表格 将鼠标放置其上，弹出编辑尺寸，个数，文字等 1234|第一列|第二列| 第三列||:----|:----:|----:||左对齐|居中|右对齐| 第一列 第二列 第三列 左对齐 居中 右对齐 居左：:---- 居中：:----:或----- 居右：----: 脚注12脚注产生的方法[^footnote].[^footnote]: *这个就是脚注* 脚注产生的方法^1 水平线输入***/—，换行键换行 12***--- 特征元素链接单击链接，展开后可编辑 ctr+单击，打开链接 超链接用[]括住要超链接的内容，紧接着用()括住超链接源+名字，超链接源后面+超链接命名 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. This is an example inline link. This link has no title attribute. 内链接相关链使用 [超链接文字]+[标签]，创建可定义链接 12345This is [an example][id] reference-style link.Then, anywhere in the document, you define your link label like this, on a line by itself:[id]: http://example.com/ &quot;Optional Title Here&quot; BaiduAnd then define the link: GoogleAnd then define the link: URLs用&lt;&gt;括住url，可手动设置url 对于标准URLs，可自动识别 12&lt;chanjian1261@gmail.com&gt;www.baidu.com chanjian1261@gmail.com www.google.com 图片 手动添加：类似链接，前面需加！ 用鼠标拖图片进入，然后鼠标放置其上修改 12![V2EX](https://upload.wikimedia.org/wikipedia/commons/e/ed/V2ex.png)![Github](https://cdn2.iconfinder.com/data/icons/black-white-social-media/64/social_media_logo_github-128.png) V2EX Github 斜体以*或__括住 123*single asterisks*_single underscores_ single asterisks single underscores 加粗开头双*或双，结尾双*或双，建议双* 123**double asterisks**__double underscores__ double asterisks double underscores 删除线用两个~开头，两个~结尾 1~~Mistaken text.~~ 错误文字. 下划线使用HTML标签 1&lt;u&gt;Underline&lt;/u&gt; Underline 代码用两个`在正常段落总表示代码 1Use t he `printf()` function. Use the printf() function. 数学式需 Preference Panel -&gt; Markdown Tab启动， 输入$，然后按ESC键，之后输入Tex命令，可预览 1$\\lim_&#123;x\\to\\infty&#125;\\exp(-x)=0$ $\\lim_{x\\to\\infty}\\exp(-x)=0$ 上下标123H&lt;sub&gt;2&lt;/sub&gt;O CO&lt;sub&gt;2&lt;/sub&gt;爆米&lt;sup&gt;TM&lt;/sup&gt; H2OCO2爆米TM 高亮需 Preference Panel -&gt; Markdown Tab启动， 使用双==括住内容, 或者利用html 的mark标签 12==highlight==&lt;mark&gt;highlight&lt;/mark&gt; highlight","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://chankin.tech/categories/Markdown/"},{"name":"Typora","slug":"Markdown/Typora","permalink":"http://chankin.tech/categories/Markdown/Typora/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://chankin.tech/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"http://chankin.tech/tags/Typora/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-31T17:00:00.000Z","updated":"2018-09-28T09:16:30.681Z","comments":true,"path":"2018/09/01/hello-world/","link":"","permalink":"http://chankin.tech/2018/09/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://chankin.tech/categories/Hexo/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://chankin.tech/tags/HTML/"}]}]}