{"meta":{"title":"Chankin's Blogs","subtitle":"以梦为马不负韶华","description":"Grasp All,Lose All.","author":"Chankin","url":"https://Chankin026.github.io"},"pages":[{"title":"About","date":"2018-09-27T12:01:10.000Z","updated":"2018-09-27T12:18:22.958Z","comments":true,"path":"About/index.html","permalink":"https://Chankin026.github.io/About/index.html","excerpt":"","text":"Java 都十分骄傲了圣诞节了"},{"title":"Tags","date":"2018-09-27T11:58:34.000Z","updated":"2018-09-27T17:28:44.696Z","comments":false,"path":"tags/index.html","permalink":"https://Chankin026.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-09-27T12:16:47.000Z","updated":"2018-09-27T17:28:58.117Z","comments":false,"path":"categories/index.html","permalink":"https://Chankin026.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java NIO:浅析I/O模型(转载)","slug":"Java-NIO-浅析I-O模型","date":"2018-10-03T10:08:31.000Z","updated":"2018-10-05T04:16:25.584Z","comments":true,"path":"2018/10/03/Java-NIO-浅析I-O模型/","link":"","permalink":"https://Chankin026.github.io/2018/10/03/Java-NIO-浅析I-O模型/","excerpt":"","text":"原博地址:https://www.cnblogs.com/dolphin0520/p/3916526.html 也许很多朋友在学习NIO的时候都会感觉有点吃力，对里面的很多概念都感觉不是那么明朗。在进入Java NIO编程之前，我们今天先来讨论一些比较基础的知识：I/O模型。下面本文先从同步和异步的概念 说起，然后接着阐述了阻塞和非阻塞的区别，接着介绍了阻塞IO和非阻塞IO的区别，然后介绍了同步IO和异步IO的区别，接下来介绍了5种IO模型，最后介绍了两种和高性能IO设计相关的设计模式（Reactor和Proactor）。 以下是本文的目录大纲： 一.什么是同步？什么是异步？ 二.什么是阻塞？什么是非阻塞？ 三.什么是阻塞IO？什么是非阻塞IO？ 四.什么是同步IO？什么是异步IO？ 五.五种IO模型 六.两种高性能IO设计模式 若有不正之处，请多多谅解并欢迎批评指正。 一.什么是同步？什么是异步？ 同步和异步的概念出来已经很久了，网上有关同步和异步的说法也有很多。以下是我个人的理解： 同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行； 异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。 这就是同步和异步。举个简单的例子，假如有一个任务包括两个子任务A和B，对于同步来说，当A在执行的过程中，B只有等待，直至A执行完毕，B才能执行；而对于异步就是A和B可以并发地执行，B不必等待A执行完毕之后再执行，这样就不会由于A的执行导致整个任务的暂时等待。 如果还不理解，可以先看下面这2段代码： 1234567891011121314void fun1() &#123; &#125; void fun2() &#123; &#125; void function()&#123; fun1(); fun2() ..... ..... &#125; 这段代码就是典型的同步，在方法function中，fun1在执行的过程中会导致后续的fun2无法执行，fun2必须等待fun1执行完毕才可以执行。 接着看下面这段代码： 123456789101112131415161718192021222324void fun1() &#123; &#125; void fun2() &#123; &#125; void function()&#123; new Thread()&#123; public void run() &#123; fun1(); &#125; &#125;.start(); new Thread()&#123; public void run() &#123; fun2(); &#125; &#125;.start(); ..... .....&#125; 这段代码是一种典型的异步，fun1的执行不会影响到fun2的执行，并且fun1和fun2的执行不会导致其后续的执行过程处于暂时的等待。 事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。我觉得可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。 因此，个人觉得同步和异步可以表现在很多方面，但是记住其关键在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。一般来说，可以通过多线程的方式来实现异步，但是千万记住不要将多线程和异步画上等号，异步只是宏观上的一个模式，采用多线程来实现异步只是一种手段，并且通过多进程的方式也可以实现异步。 二.什么是阻塞？什么是非阻塞？ 在前面介绍了同步和异步的区别，这一节来看一下阻塞和非阻塞的区别。 阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足； 非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。 这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。 举个简单的例子： 假如我要读取一个文件中的内容，如果此时文件中没有内容可读，对于同步来说就是会一直在那等待，直至文件中有内容可读；而对于非阻塞来说，就会直接返回一个标志信息告知文件中暂时无内容可读。 在网上有一些朋友将同步和异步分别与阻塞和非阻塞画上等号，事实上，它们是两组完全不同的概念。注意，理解这两组概念的区别对于后面IO模型的理解非常重要。 同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待； 而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。 理解阻塞和非阻塞可以同线程阻塞类比地理解，当一个线程进行一个请求操作时，如果条件不满足，则会被阻塞，即在那等待条件满足。 三.什么是阻塞IO？什么是非阻塞IO？ 在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。 通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。 当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段： 1）查看数据是否就绪； 2）进行数据拷贝（内核将数据拷贝到用户线程）。 那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。 Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。 四.什么是同步IO？什么是异步IO？ 我们先来看一下同步IO和异步IO的定义，在《Unix网络编程》一书中对同步IO和异步IO的定义是这样的： A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes. An asynchronous I/O operation does not cause the requesting process to be blocked. 从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞； 而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。 事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的： 对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程； 而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。 这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。 注意同步IO和异步IO与阻塞IO和非阻塞IO是不同的两组概念。 阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。 五.五种IO模型 在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。 下面就分别来介绍一下这5种IO模型的异同。 1.阻塞IO模型 最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。 当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。 典型的阻塞IO模型的例子为： 1`data = socket.read();` 如果数据没有就绪，就会一直阻塞在read方法。 2.非阻塞IO模型 当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。 典型的非阻塞IO模型一般如下： 1234567while(true)&#123; data = socket.read(); if(data!= error)&#123; 处理数据 break; &#125;&#125; 但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。 3.多路复用IO模型 多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。 在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。 在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。 也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。 而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。 另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。 不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 4.信号驱动IO模型 在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。 5.异步IO模型 异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。 也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。 注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。 前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。 六.两种高性能IO设计模式 在传统的网络服务设计模式中，有两种比较经典的模式： 一种是 多线程，一种是线程池。 对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示： 这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。 因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。 但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。 因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。 在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示： 从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。 在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。 参考资料： 《Unix网络编程》 http://blog.csdn.net/goldensuny/article/details/30717107 http://my.oschina.net/XYleung/blog/295122 http://xmuzyq.iteye.com/blog/783218 http://www.cnblogs.com/ccdev/p/3542669.html http://alicsd.iteye.com/blog/868702 http://www.smithfox.com/?e=191 http://www.cnblogs.com/Anker/p/3254269.html http://blog.csdn.net/hguisu/article/details/7453390 http://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html","categories":[{"name":"并发","slug":"并发","permalink":"https://Chankin026.github.io/categories/并发/"}],"tags":[]},{"title":"寻找两座城市之间的最小飞行次数的问题","slug":"寻找两座城市之间的最小飞行次数的问题","date":"2018-10-03T09:08:02.000Z","updated":"2018-10-03T10:35:18.059Z","comments":true,"path":"2018/10/03/寻找两座城市之间的最小飞行次数的问题/","link":"","permalink":"https://Chankin026.github.io/2018/10/03/寻找两座城市之间的最小飞行次数的问题/","excerpt":"","text":"​参考地址:《Java语言程序设计进阶篇》–[美]梁勇 (Y . Daniel Liang )著&ensp;&ensp;&ensp; 图对现实世界的问题的建模和解决非常有用。 例如,可以使用图对找寻两座城市之间最小飞行次数的问题进行建模，其中顶点代表城市,边代表两座相邻城市之间的航班。将最小飞行次数的问题就简化为找寻图中两个顶点之间的最短路径问题。 图可以用来对城市之间的飞行次数进行建模 &ensp;&ensp;&ensp;1736年伦纳德·欧拉创立了图论，当时他将地图术语用来解决著名的哥尼斯堡七孔桥.位于普鲁士的哥尼斯堡(现俄罗斯的加里宁格勒)被普罗格河分开，该河流经两座岛，这座城市和岛由七座桥相连。问题在于，如何经过没做桥一次且只经过一次,然后返回起点? 欧拉证明了这是不可能的. &ensp;&ensp;&ensp;为了证明这个结论，欧拉首先通过删除所有的街道来提取出哥尼斯堡的地图。并得到了如下图所示的草图。然后，他将每一块陆地用一个点来替换，这个点称为顶点(vertex) 或者结点(node)，并且将每一座桥用一条线来替换，这条线称为边边(edge)。这种有顶点和边的结构称为图(graph)。 &ensp;&ensp;&ensp;当看见图的时候，我们会询问是否存在一条从任意顶点出发的路径，这条路径遍历所有的边一次且只有一次，然后返回起始顶点。欧拉证明了这种路径存在的条件是，每个顶点必 须拥有偶数条边。因此，哥尼斯堡的七孔桥问题没有解决的方法。 &ensp;&ensp;&ensp;图问题经常通过算法来解决。图算法广泛应用于不同的领域，例如，计算机科学、数学、 生物学、工程学、经济学、遗传学和社会科学。下面代码运用深度优先搜索和广度优先搜索来解决最短路径问题。 图可以用来对城市之间的飞行次数进行建模 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;import java.util.Arrays;/** 寻找两座城市之间的最小飞行次数问题化简为找寻图中两个顶点之间的最短距离** 使用线性表、边数组、边对象、邻接矩阵和邻接线性表来表示顶点(代表城市)和边(代表两城市之间的航班)** 使用Gragh接口、AbstractGraph类和UnweightedGraph类来对图建模* 使用二叉树对图进行遍历* 并使用dfs和bfs回溯地图中的所有节点** */public class TestGraph &#123; public static void main(String[] args) &#123; String[] vertices = &#123;\"Beijing\", \"Shanghai\", \"Wuhan\", \"Nanjing\", \"Fuzhou\", \"Heilongjian\", \"Tianjin\", \"Hong kong\", \"Atlanta\", \"Guangdong\", \"Qiqihaer\", \"Hangzhou\"&#125;; int[][] edges = &#123; &#123;0, 1&#125;, &#123;0, 3&#125;, &#123;0, 5&#125;, &#123;1, 0&#125;, &#123;1, 2&#125;, &#123;1, 3&#125;, &#123;2, 1&#125;, &#123;2, 3&#125;, &#123;2, 4&#125;, &#123;2, 10&#125;, &#123;3, 0&#125;, &#123;3, 1&#125;, &#123;3, 2&#125;, &#123;3, 4&#125;, &#123;3, 5&#125;, &#123;4, 2&#125;, &#123;4, 3&#125;, &#123;4, 5&#125;, &#123;4, 7&#125;, &#123;4, 8&#125;, &#123;4, 10&#125;, &#123;5, 0&#125;, &#123;5, 3&#125;, &#123;5, 4&#125;, &#123;5, 6&#125;, &#123;5, 7&#125;, &#123;6, 5&#125;, &#123;6, 7&#125;, &#123;7, 4&#125;, &#123;7, 5&#125;, &#123;7, 6&#125;, &#123;7, 8&#125;, &#123;8, 4&#125;, &#123;8, 7&#125;, &#123;8, 9&#125;, &#123;8, 10&#125;, &#123;8, 11&#125;, &#123;9, 8&#125;, &#123;9, 11&#125;, &#123;10, 2&#125;, &#123;10, 4&#125;, &#123;10, 8&#125;, &#123;10, 11&#125;, &#123;11, 8&#125;, &#123;11, 9&#125;, &#123;11, 10&#125; &#125;; Graph&lt;String&gt; graph1 = new UnweightedGraph&lt;&gt;(vertices, edges); System.out.println(\"The number of vertices in graph1: \" + graph1.getSize()); System.out.println(\"The vertex with index 1 is \" + graph1.getVertex(1)); System.out.println(\"The index for Shanghai is \" + graph1.getIndex(\"Shanghai\")); System.out.println(\"The edges for graph1:\"); graph1.printEdges(); String[] names = &#123;\"Jack Ma\", \"Pony Ma\", \"李彦宏\", \"雷军\", \"刘东强\"&#125;; ArrayList&lt;AbstractGraph.Edge&gt; edgeList = new ArrayList&lt;&gt;(); edgeList.add(new AbstractGraph.Edge(0, 2)); edgeList.add(new AbstractGraph.Edge(1, 2)); edgeList.add(new AbstractGraph.Edge(2, 4)); edgeList.add(new AbstractGraph.Edge(3, 4)); Graph&lt;String&gt; graph2 = new UnweightedGraph&lt;&gt;(Arrays.asList(names), edgeList); System.out.println(\"\\nThe number of vertices in graph2: \" + graph2.getSize()); System.out.println(\"The edges for graph2:\"); graph2.printEdges(); &#125;&#125; 12345678910111213141516171819202122232425public interface Graph&lt;V&gt; &#123; public int getSize(); public java.util.List&lt;V&gt; getVertices(); public V getVertex(int index); public int getIndex(V v); public java.util.List&lt;Integer&gt; getNeighbors(int index); public int getDegree(int v); public void printEdges(); public void clear(); public boolean addVertex(V vertex); public boolean addEdge(int u, int v); public AbstractGraph&lt;V&gt;.Tree dfs(int v); public AbstractGraph&lt;V&gt;.Tree bfs(int v);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270import java.util.*;public abstract class AbstractGraph&lt;V&gt; implements Graph&lt;V&gt; &#123; protected List&lt;V&gt; vertices = new ArrayList&lt;&gt;(); protected List&lt;List&lt;Edge&gt;&gt; neighbors = new ArrayList&lt;&gt;(); protected AbstractGraph() &#123; &#125; protected AbstractGraph(V[] vertices, int[][] edges) &#123; for (int i = 0; i &lt; vertices.length; i++) addVertex(vertices[i]); createAdjacencyLists(edges, vertices.length); &#125; protected AbstractGraph(List&lt;V&gt; vertices, List&lt;Edge&gt; edges) &#123; for (int i = 0; i &lt; vertices.size(); i++) addVertex(vertices.get(i)); createAdjacencyLists(edges, vertices.size()); &#125; protected AbstractGraph(List&lt;Edge&gt; edges, int numberOfVertices) &#123; for (int i = 0; i &lt; numberOfVertices; i++) addVertex((V)(new Integer(i))); createAdjacencyLists(edges, numberOfVertices); &#125; protected AbstractGraph(int[][] edges, int numberOfVertices) &#123; for (int i = 0; i &lt; numberOfVertices; i++) addVertex((V)(new Integer(i))); // vertices is &#123;0, 1, ...&#125; createAdjacencyLists(edges, numberOfVertices); &#125; private void createAdjacencyLists( int[][] edges, int numberOfVertices) &#123; for (int i = 0; i &lt; edges.length; i++) &#123; addEdge(edges[i][0], edges[i][1]); &#125; &#125; private void createAdjacencyLists( List&lt;Edge&gt; edges, int numberOfVertices) &#123; for (Edge edge: edges) &#123; addEdge(edge.u, edge.v); &#125; &#125; @Override public int getSize() &#123; return vertices.size(); &#125; @Override public List&lt;V&gt; getVertices() &#123; return vertices; &#125; @Override public V getVertex(int index) &#123; return vertices.get(index); &#125; @Override public int getIndex(V v) &#123; return vertices.indexOf(v); &#125; @Override public List&lt;Integer&gt; getNeighbors(int index) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (Edge e: neighbors.get(index)) result.add(e.v); return result; &#125; @Override public int getDegree(int v) &#123; return neighbors.get(v).size(); &#125; @Override public void printEdges() &#123; for (int u = 0; u &lt; neighbors.size(); u++) &#123; System.out.print(getVertex(u) + \" (\" + u + \"): \"); for (Edge e: neighbors.get(u)) &#123; System.out.print(\"(\" + getVertex(e.u) + \", \" + getVertex(e.v) + \") \"); &#125; System.out.println(); &#125; &#125; @Override public void clear() &#123; vertices.clear(); neighbors.clear(); &#125; @Override public boolean addVertex(V vertex) &#123; if (!vertices.contains(vertex)) &#123; vertices.add(vertex); neighbors.add(new ArrayList&lt;Edge&gt;()); return true; &#125; else &#123; return false; &#125; &#125; protected boolean addEdge(Edge e) &#123; if (e.u &lt; 0 || e.u &gt; getSize() - 1) throw new IllegalArgumentException(\"No such index: \" + e.u); if (e.v &lt; 0 || e.v &gt; getSize() - 1) throw new IllegalArgumentException(\"No such index: \" + e.v); if (!neighbors.get(e.u).contains(e)) &#123; neighbors.get(e.u).add(e); return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean addEdge(int u, int v) &#123; return addEdge(new Edge(u, v)); &#125; public static class Edge &#123; public int u; public int v; public Edge(int u, int v) &#123; this.u = u; this.v = v; &#125; public boolean equals(Object o) &#123; return u == ((Edge)o).u &amp;&amp; v == ((Edge)o).v; &#125; &#125; @Override public Tree dfs(int v) &#123; List&lt;Integer&gt; searchOrder = new ArrayList&lt;&gt;(); int[] parent = new int[vertices.size()]; for (int i = 0; i &lt; parent.length; i++) parent[i] = -1; boolean[] isVisited = new boolean[vertices.size()]; dfs(v, parent, searchOrder, isVisited); return new Tree(v, parent, searchOrder); &#125; private void dfs(int u, int[] parent, List&lt;Integer&gt; searchOrder, boolean[] isVisited) &#123; searchOrder.add(u); isVisited[u] = true; for (Edge e : neighbors.get(u)) &#123; if (!isVisited[e.v]) &#123; parent[e.v] = u; dfs(e.v, parent, searchOrder, isVisited); &#125; &#125; &#125; @Override public Tree bfs(int v) &#123; List&lt;Integer&gt; searchOrder = new ArrayList&lt;&gt;(); int[] parent = new int[vertices.size()]; for (int i = 0; i &lt; parent.length; i++) parent[i] = -1; java.util.LinkedList&lt;Integer&gt; queue = new java.util.LinkedList&lt;&gt;(); boolean[] isVisited = new boolean[vertices.size()]; queue.offer(v); isVisited[v] = true; while (!queue.isEmpty()) &#123; int u = queue.poll(); searchOrder.add(u); for (Edge e: neighbors.get(u)) &#123; if (!isVisited[e.v]) &#123; queue.offer(e.v); parent[e.v] = u; isVisited[e.v] = true; &#125; &#125; &#125; return new Tree(v, parent, searchOrder); &#125; public class Tree &#123; private int root; private int[] parent; private List&lt;Integer&gt; searchOrder; public Tree(int root, int[] parent, List&lt;Integer&gt; searchOrder) &#123; this.root = root; this.parent = parent; this.searchOrder = searchOrder; &#125; public int getRoot() &#123; return root; &#125; public int getParent(int v) &#123; return parent[v]; &#125; public List&lt;Integer&gt; getSearchOrder() &#123; return searchOrder; &#125; public int getNumberOfVerticesFound() &#123; return searchOrder.size(); &#125; public List&lt;V&gt; getPath(int index) &#123; ArrayList&lt;V&gt; path = new ArrayList&lt;&gt;(); do &#123; path.add(vertices.get(index)); index = parent[index]; &#125; while (index != -1); return path; &#125; public void printPath(int index) &#123; List&lt;V&gt; path = getPath(index); System.out.print(\"A path from \" + vertices.get(root) + \" to \" + vertices.get(index) + \": \"); for (int i = path.size() - 1; i &gt;= 0; i--) System.out.print(path.get(i) + \" \"); &#125; public void printTree() &#123; System.out.println(\"Root is: \" + vertices.get(root)); System.out.print(\"Edges: \"); for (int i = 0; i &lt; parent.length; i++) &#123; if (parent[i] != -1) &#123; System.out.print(\"(\" + vertices.get(parent[i]) + \", \" + vertices.get(i) + \") \"); &#125; &#125; System.out.println(); &#125; &#125;&#125; 123456789101112131415161718192021import java.util.*;public class UnweightedGraph&lt;V&gt; extends AbstractGraph&lt;V&gt; &#123; public UnweightedGraph() &#123; &#125; public UnweightedGraph(V[] vertices, int[][] edges) &#123; super(vertices, edges); &#125; public UnweightedGraph(List&lt;V&gt; vertices, List&lt;Edge&gt; edges) &#123; super(vertices, edges); &#125; public UnweightedGraph(List&lt;Edge&gt; edges, int numberOfVertices) &#123; super(edges, numberOfVertices); &#125; public UnweightedGraph(int[][] edges, int numberOfVertices) &#123; super(edges, numberOfVertices); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://Chankin026.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://Chankin026.github.io/tags/算法/"}]},{"title":"AVL树的简单实现","slug":"AVL树的简单实现","date":"2018-10-01T14:15:16.000Z","updated":"2018-10-01T14:37:06.360Z","comments":true,"path":"2018/10/01/AVL树的简单实现/","link":"","permalink":"https://Chankin026.github.io/2018/10/01/AVL树的简单实现/","excerpt":"","text":"AVL树是一种自平衡的二叉搜索树（BST），两者之间的区别在于AVL树的左右子树高度之间的差异(平和因子)不能超过1。(树的高度约定为：空结点（空子树）的高度为-1，叶子结点的高度为0)高度和深度有区别,详细了解请看下一下链接 AVL的详细定义:java数据结构与算法之平衡二叉树(AVL树)的设计与实现(其实现和以下代码有点区别,但本质是一样的通过旋转来实现平衡) 实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207public class AVLTree&lt;T extends Comparable&lt;T&gt;&gt;&#123; class AVLNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; public AVLNode&lt;T&gt; left; public AVLNode&lt;T&gt; right; public T data; public int height; public AVLNode(AVLNode&lt;T&gt; left, AVLNode&lt;T&gt; right, T data)&#123; this.left = left; this.right = right; this.data = data; this.height = 0; &#125; &#125; public AVLNode&lt;T&gt; root; public AVLTree() &#123; root = null; &#125; /* * @param x 失衡点 * @ return w 根节点 * */ private AVLNode&lt;T&gt; leftRotation(AVLNode&lt;T&gt; x)&#123; AVLNode&lt;T&gt; w = x.left; x.left = w.right; w.right = x; w.height = Math.max(height(w.left), height(w.right))+ 1; x.height = Math.max(height(x.left), x.height)+ 1; return w; &#125; private AVLNode&lt;T&gt; rightRotation(AVLNode&lt;T&gt; w)&#123; AVLNode&lt;T&gt; x = w.right; w.right = x.left; x.left = w; w.height = Math.max(height(w.left), height(w.right))+ 1; x.height = Math.max(height(x.left), height(x.right))+ 1; return x; &#125; private AVLNode&lt;T&gt; leftRightRotation(AVLNode&lt;T&gt; x)&#123; x.left = rightRotation(x.left); return leftRotation(x); &#125; private AVLNode&lt;T&gt; rightLeftRotation(AVLNode&lt;T&gt; x)&#123; x.right = leftRotation(x.right); return rightRotation(x); &#125; public void insert(T data)&#123; if(root == null) &#123; root = new AVLNode&lt;T&gt;(null,null,data); if (data == null) &#123; throw new RuntimeException(\"data can\\'t be null\"); &#125; &#125; root = insert(root,data);//返回根节点 &#125; private AVLNode&lt;T&gt; insert(AVLNode&lt;T&gt; node, T data)&#123;// node 为根节点 if (node == null) &#123; // 新建节点 node = new AVLNode&lt;T&gt;(null,null,data); if (node == null) &#123; System.out.println(\"ERROR: create avltree node failed!\"); return null; &#125; &#125; if(data.compareTo(node.data) &lt; 0)&#123; node.left = insert(node.left, data); if(height(node.left) - height(node.right) == 2)&#123; if(data.compareTo(node.left.data) &lt; 0)&#123; node = leftRotation(node); &#125;else&#123; node = leftRightRotation(node); &#125; &#125; &#125;else if( data.compareTo(node.data) &gt; 0 )&#123; node.right = insert(node.right, data); if(height(node.right) - height(node.left) == 2)&#123; if(data.compareTo(node.right.data) &gt; 0)&#123; node = rightRotation(node); &#125;else&#123; node = rightLeftRotation(node); &#125; &#125; &#125; else &#123; node.height =Math.max(height(node.left), height(node.right)) + 1; &#125; return node; &#125; private int height(AVLNode&lt;T&gt; tree) &#123; if (tree != null) return tree.height; return 0; &#125; /* * 删除操作 * @param data * @param node * @param return */ public AVLNode&lt;T&gt; remove(T data)&#123; if(data == null)&#123; throw new RuntimeException(\"data can't be null\"); &#125; return root = remove(root, data); &#125; private AVLNode&lt;T&gt; remove(AVLNode&lt;T&gt; node, T data)&#123; if( node == null) return null; if( data.compareTo(node.data) &gt; 0) &#123; return remove(node.right, data); &#125;else if(data.compareTo(node.data) &lt; 0)&#123; return remove(node.left, data); &#125; if (node.left == null || node.right == null) &#123; if ((node.left == null) &amp;&amp; (node.right == null)) &#123; node = null; &#125; else if ((node.left != null) &amp;&amp; (node.right == null)) &#123; node = node.left; if(node.height - node.height == 2) &#123; if (data.compareTo(node.left.data) &lt; 0) &#123; node = leftRotation(node); &#125; else &#123; node = leftRightRotation(node); &#125; &#125; &#125; else if ((node.left == null) &amp;&amp; (node.right != null)) &#123; node = node.right; if(node.right.height - node.left.height == 2)&#123; if(data.compareTo(node.data) &lt; 0)&#123; node = rightLeftRotation(node); &#125;else&#123; node = rightRotation(node); &#125; &#125; &#125; &#125; else &#123; if (node.left.height &gt;node.right.height) &#123; node.data = findMax(); node.left = remove(node.left, node.data); &#125; else &#123; node.data = findMin(); node.right = remove(node.right, node.data); &#125; &#125; node.height = Math.max(node.left.height, node.right.height); return node; &#125; public T findMin() &#123; AVLNode&lt;T&gt; node = findMin(root); if(node != null) return node.data; return null; &#125; public T findMax()&#123; AVLNode&lt;T&gt; node = findMax(root); if(node != null) return node.data; return null; &#125; /* * 查找最小值结点 * @param node * @return */ private AVLNode&lt;T&gt; findMin(AVLNode&lt;T&gt; node)&#123; if (node == null)//结束条件 return null; while (node.left !=null)//如果没有左结点,那么t就是最小的 node = node.left; return node; &#125; /* * 查找最小值结点 * @param node * @return */ private AVLNode&lt;T&gt; findMax(AVLNode&lt;T&gt; node)&#123; if (node == null)//结束条件 return null; while (node.right !=null)//如果没有左结点,那么t就是最小的 node = node.right; return node; &#125;&#125;class AVLTreeTest&#123; public static void main(String[] args)&#123; AVLTree&lt;Integer&gt; avlTree = new AVLTree&lt;&gt;(); for (int i = 1; i &lt;18 ; i++) &#123; avlTree.insert(i); System.out.println(i); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://Chankin026.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Chankin026.github.io/tags/数据结构/"}]},{"title":"二叉树的简单实现","slug":"二叉树的简单实现","date":"2018-10-01T13:54:03.000Z","updated":"2018-10-01T14:08:41.572Z","comments":true,"path":"2018/10/01/二叉树的简单实现/","link":"","permalink":"https://Chankin026.github.io/2018/10/01/二叉树的简单实现/","excerpt":"","text":"二叉树的实现,其查找、插入、删除等操作 关键在于当前节点 和根节点进行比较,小于则于左子树比较,大于则于右子树比较 ,然后根据递归实现。 以前不知道什么时候实现的,好像没什么问题 ,就传上来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class BinaryTree&lt;K extends Comparable&lt;K&gt;,V&gt; &#123; private Node root; private int foot = 0; private int count; private Object[] array; public static class Entry&lt;K extends Comparable&lt;K&gt;, V&gt; implements Comparable&lt;K&gt; &#123; private K key; private V value; public Entry(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return this.key; &#125; public V getValue() &#123; return this.value; &#125; public int compareTo(K o) &#123; return this.key.compareTo(o); &#125; &#125; private class Node &#123; private Node left; private Node right; private Node parent; private BinaryTree.Entry&lt;K, V&gt; data; public V getNode(K key) &#123; if (key.compareTo(this.data.key) == 0) &#123; return this.data.value; &#125; else if (key.compareTo(this.data.key) &lt; 0) &#123; if (this.left != null) &#123; return this.left.getNode(key); &#125; else &#123; return null; &#125; &#125; else &#123; if (this.right != null) &#123; return this.right.getNode(key); &#125; else &#123; return null; &#125; &#125; &#125; public Node(BinaryTree.Entry&lt;K, V&gt; data) &#123; this.data = data; &#125; public boolean containsNode(BinaryTree.Entry&lt;K, V&gt; data) &#123; if (data.key.compareTo(this.data.key) == 0) &#123; return true; &#125; else if (data.key.compareTo(this.data.key) &lt; 0) &#123; return this.left.containsNode(data); &#125; else &#123; return this.right.containsNode(data); &#125; &#125; public void addNode(Node newNode) &#123; if (newNode.data.key.compareTo(this.data.key) == 0) &#123; new Exception(\"该数值已经存在\"); &#125; else if (newNode.data.key.compareTo(this.data.key) &lt; 0) &#123; if (this.left == null) &#123; this.left = newNode; newNode.parent = this; &#125; else &#123; this.left.addNode(newNode); &#125; &#125; else &#123; if (this.right == null) &#123; this.right = newNode; newNode.parent = this; &#125; else &#123; this.right.addNode(newNode); &#125; &#125; &#125; public void toArrayNode() &#123; if (this.left != null) &#123; this.left.toArrayNode(); &#125; BinaryTree.this.array[BinaryTree.this.foot++] = this.data; if (this.right != null) &#123; this.right.toArrayNode(); &#125; &#125; &#125; public Object[] toArray() &#123; if (this.count == 0) &#123; return null; &#125; this.array = new Object[this.count]; this.foot = 0; this.root.toArrayNode(); return this.array; &#125; public boolean contrains(K key) &#123; if (this.count == 0) &#123; return false; &#125; return this.root.containsNode(new BinaryTree.Entry(key, null)); &#125; public void add(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException(\"faksdlfj;lk\"); &#125; Node newNode = new Node(new BinaryTree.Entry(key, value)); if (this.root == null) &#123; this.root = newNode; &#125; else &#123; this.root.addNode(newNode); &#125; this.count++; &#125; public V getKey(K key)&#123; if(this.count== 0 || key == null)&#123; return null; &#125; return this.root.getNode(key); &#125;&#125;class Person &#123; public int age; public String name; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public String toString()&#123; return \"特性: \" + this.name + \" 值 = \" + this.age + \"\\n\"; &#125;&#125;class Ts&#123; public static void main(String[] args)&#123; BinaryTree&lt;Integer,Person&gt; s = new BinaryTree&lt;Integer,Person&gt;(); s.add(1,new Person(\"一致性\",11)); s.add(2,new Person(\"原子性\",22)); s.add(3,new Person(\"隔离性\",333)); s.add(4,new Person(\"完整性\",444)); s.add(5,new Person(\"持久性\",555)); Object result[] = s.toArray(); for(Object ojb: result)&#123; BinaryTree.Entry&lt;Integer,Person&gt; entry = (BinaryTree.Entry&lt;Integer,Person&gt;)ojb; System.out.println(entry.getKey() + \"===\" + entry.getValue()); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://Chankin026.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Chankin026.github.io/tags/数据结构/"}]},{"title":"剑指Offer--根据前序遍历和中序遍历重建二叉树","slug":"剑指Offer-根据前序遍历和中序遍历重建二叉树","date":"2018-10-01T12:00:56.000Z","updated":"2018-10-01T13:54:26.992Z","comments":true,"path":"2018/10/01/剑指Offer-根据前序遍历和中序遍历重建二叉树/","link":"","permalink":"https://Chankin026.github.io/2018/10/01/剑指Offer-根据前序遍历和中序遍历重建二叉树/","excerpt":"","text":"题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{1,2,4,7,3,5,6,8}，则重建二叉树并返回。 二叉树前序遍历Preorder Traversal: 根-左-右{1,2,4,7,3,5,6,8} 二叉树中序遍历Inorder Traversal: 左-根-右{1,2,4,7,3,5,6,8} 可以判断出前序遍历第一点一定是根节点,然后在根据 利用while循环找出中序遍历的根节点的index; 根据根节点判断出中序遍历左边部分是左子树,右边是右子树; 根据中序遍历了第一点和根节点判断偏移量index-startIn(循环第一次是index为3); 中序遍历根节点左边第一点就是左子树最后一个节点(最大点)index-startIn +startPre (前序第一点加偏移量); 前序遍历左子树最后一个节点的后一点 index-startIn+startPre+1就是右子树第一点,index+1中序遍历右子树的第一点; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** jdk 1.8 * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre == null || in == null)&#123; return null; &#125; TreeNode root = reConstruct(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; /** * * @param pre 前序遍历 * @param startPre 前序遍历的开始点 * @param endPre 前序遍历的结束点 * @param in 中序遍历 * @param startIn 中序遍历的开始点 * @param endIn 中序遍历的结束位点 * @return root 树的根节点 */ private TreeNode reConstruct(int[] pre,int startPre,int endPre,int[] in,int startIn,int endIn )&#123; if(startPre &gt; endPre||startIn &gt; endIn)&#123; return null; &#125; TreeNode root = new TreeNode(pre[startPre]);//创建当前节点 for(int index=startIn;index&lt;=endIn;index++) if(in[index]==pre[startPre])&#123; //找出中序遍历当前节点的位置 //递归实现遍历左子树 root.left=reConstruct(pre,startPre+1,index-startIn +startPre,in,startIn,index-1); //递归实现遍历右子树 root.right=reConstruct(pre,index-startIn+startPre + 1,endPre,in,index+1,endIn); &#125; return root; &#125;&#125; Ps:真的有点难,用递归完全想不到,就是题做得太少了 参考： https://www.cnblogs.com/zywu/p/5758917.html https://segmentfault.com/a/1190000012207144","categories":[{"name":"算法","slug":"算法","permalink":"https://Chankin026.github.io/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://Chankin026.github.io/categories/算法/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Chankin026.github.io/tags/数据结构/"}]},{"title":"利用JSP发送邮件附件","slug":"利用JSP发送邮件附件","date":"2018-09-29T01:21:44.000Z","updated":"2018-10-05T01:22:32.716Z","comments":true,"path":"2018/09/29/利用JSP发送邮件附件/","link":"","permalink":"https://Chankin026.github.io/2018/09/29/利用JSP发送邮件附件/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;简单实现一个发送邮件正文和附件的例子,其中利用Java Mail jar包和JAF的activation jar包.下面的例子实现了从163邮箱发送邮件到qq邮箱, 其中 message.setSubject( &quot;邮件主题&quot; )设置邮件主题 messageBodyPart.setText(&quot;邮件正文&quot;)设置邮件正文内容 String filename = &quot;C:\\\\apache-tomcat-7.0.90\\\\webapps\\\\ROOT\\\\file.txt&quot;设置 邮件附件绝对路径, 分隔符\\需要转义 当然如果想换个邮箱进行发送,只需改一下邮箱服务器smtp.163.com,默认端口25采用SMTP协议 1234//SMTP邮件服务器properties.setProperty( &quot;mail.smtp.host&quot;, &quot;smtp.163.com&quot; ); //SMTP邮件服务器默认端口properties.setProperty( &quot;mail.smtp.port&quot;, &quot;25&quot; ); 常见的邮箱STMP服务器:https://blog.csdn.net/ning521513/article/details/79217203 所需jar下载地址: Java Mail Activation 其他信息备注都写的很详细 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!-- 163邮箱发送带有附件的邮件到qq邮箱 --&gt;&lt;%@ page import=\"java.util.*\" %&gt;&lt;%@ page import=\"javax.mail.*\" %&gt;&lt;%@ page import=\"javax.mail.internet.*\" %&gt;&lt;%@ page import=\"javax.activation.*\" %&gt;&lt;% String result; // 收件人的电子邮件 String to = \"abc@qq.com\"; // 发件人的电子邮件名和密碼 String from = \"abcd@163.com\"; String psd = \"abcd\"; //设置邮箱用户名 String user = \"abcd\"; Properties properties = new Properties(); try &#123; // 设置用户的认证方式 properties.setProperty( \"mail.smtp.auth\", \"true\" ); //设置传输协议 properties.setProperty( \"mail.transport.protocol\", \"smtp\" ); //SMTP邮件服务器 properties.setProperty( \"mail.smtp.host\", \"smtp.163.com\" ); //SMTP邮件服务器默认端口 properties.setProperty( \"mail.smtp.port\", \"25\" ); // 获取默认的Session对象。 Session mailSession = Session.getDefaultInstance( properties ); // 创建一个默认的MimeMessage对象。 Message message = new MimeMessage( mailSession ); // 根据session对象获取邮件传输对象Transport Transport transport = mailSession.getTransport(); // 设置 From: 头部的header字段 message.setFrom( new InternetAddress( from ) ); // 设置 To: 头部的header字段 message.addRecipient( Message.RecipientType.TO, new InternetAddress( to ) ); // 设置 Subject: header字段 message.setSubject( \"This is the Subject Line!\" ); // 现在设置的实际消息 BodyPart messageBodyPart = new MimeBodyPart(); //发送邮件的正文内容 messageBodyPart.setText(\"This is message body\"); Multipart multipart = new MimeMultipart(); multipart.addBodyPart(messageBodyPart); messageBodyPart = new MimeBodyPart(); //使用绝对路径 String filename = \"C:\\\\apache-tomcat-7.0.90\\\\webapps\\\\ROOT\\\\file.txt\"; //添加文件到message DataSource source = new FileDataSource(filename); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(filename); multipart.addBodyPart(messageBodyPart); message.setContent(multipart); message.setSentDate(new Date()); // 设置发件人的账户名和密码 transport.connect(user,psd); // 发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage( message, message.getAllRecipients() ); result = \"Sent message successfully....\"; &#125; catch (Exception e) &#123; e.printStackTrace(); result = \"Error: unable to send message....\"; &#125;%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Send Email using JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;Send Email using JSP&lt;/h1&gt; &lt;/center&gt; &lt;p align=\"center\"&gt; &lt;% out.println(\"Result: \" + result + \"\\n\"); %&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JSP","slug":"JSP","permalink":"https://Chankin026.github.io/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://Chankin026.github.io/tags/JSP/"}]},{"title":"Hexo-theme-indigo解决置顶问题","slug":"Hexo-theme-indigo解决置顶问题","date":"2018-09-28T15:51:29.000Z","updated":"2018-09-28T16:13:26.740Z","comments":true,"path":"2018/09/28/Hexo-theme-indigo解决置顶问题/","link":"","permalink":"https://Chankin026.github.io/2018/09/28/Hexo-theme-indigo解决置顶问题/","excerpt":"","text":"将node_modules/hexo-generator-index/lib/generator.js的文件内容替换成一下内容 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在新建的md日志文件种加入top初始化命令比如说： 12345title: Hexo置顶文章date: 2016-11-11 23:26:22tags:categories: Hexotop: 0 #0或者1 当top的值取0的时候，表示默认排序，即是按照时间顺序来排序。 当top的值取1到无为置顶文件限大的时候，值最高的md文件即是置顶文章","categories":[],"tags":[]},{"title":"sql语句练习51题","slug":"sql语句练习51题","date":"2018-09-28T13:13:45.000Z","updated":"2018-09-28T13:36:43.874Z","comments":true,"path":"2018/09/28/sql语句练习51题/","link":"","permalink":"https://Chankin026.github.io/2018/09/28/sql语句练习51题/","excerpt":"","text":"&emsp;&emsp; 习题来源于网络，难度会稍高, sql语句是一部分自己写的，一部分是参考的(前23题当时没保存,直接拷贝原博)。其中有很多大神的牛逼写法,也有我自己比较差劲的写法。 源自: sql语句练习50题(Mysql版)CSDN博客 表名和字段 学生表 : Student(s_id,s_name,s_birth,s_sex) – –学生编号,学生姓名, 出生年月,学生性别 课程表 :Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号 教师表:Teacher(t_id,t_name) – –教师编号,教师姓名 成绩表Score(s_id,c_id,s_score) – – 学生编号,课程编号,分数 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--建表--学生表CREATE TABLE `Student`(`s_id` VARCHAR(20),`s_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`s_birth` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`s_sex` VARCHAR(10) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY(`s_id`));--课程表CREATE TABLE `Course`(`c_id` VARCHAR(20),`c_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`t_id` VARCHAR(20) NOT NULL,PRIMARY KEY(`c_id`));--教师表CREATE TABLE `Teacher`(`t_id` VARCHAR(20),`t_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY(`t_id`));--成绩表CREATE TABLE `Score`(`s_id` VARCHAR(20),`c_id` VARCHAR(20),`s_score` INT(3),PRIMARY KEY(`s_id`,`c_id`));--插入学生表测试数据insert into Student values(&apos;01&apos; , &apos;赵雷&apos; , &apos;1990-01-01&apos; , &apos;男&apos;);insert into Student values(&apos;02&apos; , &apos;钱电&apos; , &apos;1990-12-21&apos; , &apos;男&apos;);insert into Student values(&apos;03&apos; , &apos;孙风&apos; , &apos;1990-05-20&apos; , &apos;男&apos;);insert into Student values(&apos;04&apos; , &apos;李云&apos; , &apos;1990-08-06&apos; , &apos;男&apos;);insert into Student values(&apos;05&apos; , &apos;周梅&apos; , &apos;1991-12-01&apos; , &apos;女&apos;);insert into Student values(&apos;06&apos; , &apos;吴兰&apos; , &apos;1992-03-01&apos; , &apos;女&apos;);insert into Student values(&apos;07&apos; , &apos;郑竹&apos; , &apos;1989-07-01&apos; , &apos;女&apos;);insert into Student values(&apos;08&apos; , &apos;王菊&apos; , &apos;1990-01-20&apos; , &apos;女&apos;);--课程表测试数据insert into Course values(&apos;01&apos; , &apos;语文&apos; , &apos;02&apos;);insert into Course values(&apos;02&apos; , &apos;数学&apos; , &apos;01&apos;);insert into Course values(&apos;03&apos; , &apos;英语&apos; , &apos;03&apos;);--教师表测试数据insert into Teacher values(&apos;01&apos; , &apos;张三&apos;);insert into Teacher values(&apos;02&apos; , &apos;李四&apos;);insert into Teacher values(&apos;03&apos; , &apos;王五&apos;);--成绩表测试数据insert into Score values(&apos;01&apos; , &apos;01&apos; , 80);insert into Score values(&apos;01&apos; , &apos;02&apos; , 90);insert into Score values(&apos;01&apos; , &apos;03&apos; , 99);insert into Score values(&apos;02&apos; , &apos;01&apos; , 70);insert into Score values(&apos;02&apos; , &apos;02&apos; , 60);insert into Score values(&apos;02&apos; , &apos;03&apos; , 80);insert into Score values(&apos;03&apos; , &apos;01&apos; , 80);insert into Score values(&apos;03&apos; , &apos;02&apos; , 80);insert into Score values(&apos;03&apos; , &apos;03&apos; , 80);insert into Score values(&apos;04&apos; , &apos;01&apos; , 50);insert into Score values(&apos;04&apos; , &apos;02&apos; , 30);insert into Score values(&apos;04&apos; , &apos;03&apos; , 20);insert into Score values(&apos;05&apos; , &apos;01&apos; , 76);insert into Score values(&apos;05&apos; , &apos;02&apos; , 87);insert into Score values(&apos;06&apos; , &apos;01&apos; , 31);insert into Score values(&apos;06&apos; , &apos;03&apos; , 34);insert into Score values(&apos;07&apos; , &apos;02&apos; , 89);insert into Score values(&apos;07&apos; , &apos;03&apos; , 98); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381-- * 查询每门课程选修的同学信息SELECT a.*, b.c_id FROM student a RIGHT JOIN score b ON a.s_id = b.s_id WHERE b.c_id in( SELECT c.c_id FROM score c GROUP BY c.c_id HAVING count(*)) order by c_id;-- 1、查询&quot;01&quot;课程比&quot;02&quot;课程成绩高的学生的信息及课程分数 select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a join score b on a.s_id=b.s_id and b.c_id=&apos;01&apos; left join score c on a.s_id=c.s_id and c.c_id=&apos;02&apos; or c.c_id = NULL where b.s_score&gt;c.s_score-- 2、查询&quot;01&quot;课程比&quot;02&quot;课程成绩低的学生的信息及课程分数select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a left join score b on a.s_id=b.s_id and b.c_id=&apos;01&apos; or b.c_id=NULL join score c on a.s_id=c.s_id and c.c_id=&apos;02&apos; where b.s_score&lt;c.s_score-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b join score a on b.s_id = a.s_id GROUP BY b.s_id,b.s_name HAVING ROUND(AVG(a.s_score),2)&gt;=60;-- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩 -- (包括有成绩的和无成绩的)select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b left join score a on b.s_id = a.s_id GROUP BY b.s_id,b.s_name HAVING ROUND(AVG(a.s_score),2)&lt;60 unionselect a.s_id,a.s_name,0 as avg_score from student a where a.s_id not in ( select distinct s_id from score);-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩select a.s_id,a.s_name,count(b.c_id) as sum_course,sum(b.s_score) as sum_score from student a left join score b on a.s_id=b.s_id GROUP BY a.s_id,a.s_name;-- 6、查询&quot;李&quot;姓老师的数量 select count(t_id) from teacher where t_name like &apos;李%&apos;;-- 7、查询学过&quot;张三&quot;老师授课的同学的信息 select a.* from student a join score b on a.s_id=b.s_id where b.c_id in( select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;));-- 8、查询没学过&quot;张三&quot;老师授课的同学的信息 select * from student c where c.s_id not in( select a.s_id from student a join score b on a.s_id=b.s_id where b.c_id in( select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;)))-- 9、查询学过编号为&quot;01&quot;并且也学过编号为&quot;02&quot;的课程的同学的信息select a.* from student a,score b,score c where a.s_id = b.s_id and a.s_id = c.s_id and b.c_id=&apos;01&apos; and c.c_id=&apos;02&apos;;-- 10、查询学过编号为&quot;01&quot;但是没有学过编号为&quot;02&quot;的课程的同学的信息select a.* from student a where a.s_id in (select s_id from score where c_id=&apos;01&apos; ) and a.s_id not in(select s_id from score where c_id=&apos;02&apos;)-- 11、查询没有学全所有课程的同学的信息 --第一种 select s.* from student s where s.s_id in( select s_id from score where s_id not in( select a.s_id from score a join score b on a.s_id = b.s_id and b.c_id=&apos;02&apos; join score c on a.s_id = c.s_id and c.c_id=&apos;03&apos; where a.c_id=&apos;01&apos;)) --第二种 SELECT a.* FROM student a RIGHT JOIN (SELECT s_id, count(*) FROM score GROUP BY s_id HAVING count(c_id) &lt; (SELECT count(*) FROM course)) AS b ON a.s_id = b.s_id -- 12、查询至少有一门课与学号为&quot;01&quot;的同学所学相同的同学的信息 select * from student where s_id in( select distinct a.s_id from score a where a.c_id in(select a.c_id from score a where a.s_id=&apos;01&apos;) )-- 13、查询和&quot;01&quot;号的同学学习的课程完全相同的其他同学的信息 select a.* from student a where a.s_id in( select distinct s_id from score where s_id!=&apos;01&apos; and c_id in(select c_id from score where s_id=&apos;01&apos;) group by s_id having count(1)=(select count(1) from score where s_id=&apos;01&apos;));-- 14、查询没学过&quot;张三&quot;老师讲授的任一门课程的学生姓名 select a.s_name from student a where a.s_id not in ( select s_id from score where c_id = (select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;)) group by s_id);-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 select a.s_id,a.s_name,ROUND(AVG(b.s_score)) from student a left join score b on a.s_id = b.s_id where a.s_id in( select s_id from score where s_score&lt;60 GROUP BY s_id having count(1)&gt;=2) GROUP BY a.s_id,a.s_name-- 16、检索&quot;01&quot;课程分数小于60，按分数降序排列的学生信息select a.*,b.c_id,b.s_score from student a,score b where a.s_id = b.s_id and b.c_id=&apos;01&apos; and b.s_score&lt;60 ORDER BY b.s_score DESC;-- 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩select a.s_id,(select s_score from score where s_id=a.s_id and c_id=&apos;01&apos;) as 语文, (select s_score from score where s_id=a.s_id and c_id=&apos;02&apos;) as 数学, (select s_score from score where s_id=a.s_id and c_id=&apos;03&apos;) as 英语, round(avg(s_score),2) as 平均分 from score a GROUP BY a.s_id ORDER BY 平均分 DESC;-- 18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率--及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90select a.c_id,b.c_name,MAX(s_score),MIN(s_score),ROUND(AVG(s_score),2), ROUND(100*(SUM(case when a.s_score&gt;=60 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 及格率, ROUND(100*(SUM(case when a.s_score&gt;=70 and a.s_score&lt;=80 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 中等率, ROUND(100*(SUM(case when a.s_score&gt;=80 and a.s_score&lt;=90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 优良率, ROUND(100*(SUM(case when a.s_score&gt;=90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 优秀率 from score a left join course b on a.c_id = b.c_id GROUP BY a.c_id,b.c_name-- 19、按各科成绩进行排序，并显示排名(实现不完全)-- mysql没有rank函数 select a.s_id,a.c_id, @i:=@i +1 as i保留排名, @k:=(case when @score=a.s_score then @k else @i end) as rank不保留排名, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;01&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s union select a.s_id,a.c_id, @i:=@i +1 as i, @k:=(case when @score=a.s_score then @k else @i end) as rank, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;02&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s union select a.s_id,a.c_id, @i:=@i +1 as i, @k:=(case when @score=a.s_score then @k else @i end) as rank, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;03&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s-- 20、查询学生的总成绩并进行排名 select a.s_id, @i:=@i+1 as i, @k:=(case when @score=a.sum_score then @k else @i end) as rank, @score:=a.sum_score as score from (select s_id,SUM(s_score) as sum_score from score GROUP BY s_id ORDER BY sum_score DESC)a, (select @k:=0,@i:=0,@score:=0)s-- 21、查询不同老师所教不同课程平均分从高到低显示 select a.t_id,c.t_name,a.c_id,ROUND(avg(s_score),2) as avg_score from course a left join score b on a.c_id=b.c_id left join teacher c on a.t_id=c.t_id GROUP BY a.c_id,a.t_id,c.t_name ORDER BY avg_score DESC;-- 22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩 select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@i:=@i+1 as 排名 from score a,(select @i:=0)s where a.c_id=&apos;01&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@j:=@j+1 as 排名 from score a,(select @j:=0)s where a.c_id=&apos;02&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@k:=@k+1 as 排名 from score a,(select @k:=0)s where a.c_id=&apos;03&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3; -- 23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比 select distinct f.c_name,a.c_id,b.`85-100`,b.百分比,c.`70-85`,c.百分比,d.`60-70`,d.百分比,e.`0-60`,e.百分比 from score a LEFT JOIN (select c_id,sum(case when s_score &gt; 85 and s_score &lt;= 100 then 1 else 0 end) as `85-100`,100*(sum(case when s_score &gt; 85 and s_score &lt;= 100 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) b on a.c_id = b.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 70 and s_score &lt;= 85 then 1 else 0 end) as `70-85`,100*(sum(case when s_score &gt; 70 and s_score &lt;= 85 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) c on a.c_id = c.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 60 and s_score &lt;= 70 then 1 else 0 end) as `60-70`,100*(sum(case when s_score &gt; 60 and s_score &lt;= 70 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) d on a.c_id = d.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 0 and s_score &lt;= 60 then 1 else 0 end) as `0-60`,100*(sum(case when s_score &gt; 0 and s_score &lt;= 60 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) e on a.c_id = e.c_id left join course f on a.c_id = f.c_id-- 24、查询学生平均成绩及其名次 SELECT a.s_id , @i :=@i+ 1 AS 名次 , @k := avg_s AS 平均分 FROM (SELECT s_id, avg(s_score) AS avg_s FROM score GROUP BY s_id) a, (SELECT @k := 0 ,@i := 0) b order by 平均分 desc -- 25、查询各科成绩前三名的记录 -- 1.选出b表比a表成绩大的所有组 -- 2.选出比当前id成绩大的 小于三个的 SELECT DISTINCT a.s_id, a.c_id,a.s_score FROM score a LEFT JOIN score b ON a.c_id = b.c_id AND a.s_score &lt; b.s_score GROUP BY a.s_id, a.c_id, a.s_score HAVING COUNT(a.s_id) &lt; 3 ORDER BY a.c_id,a.s_score DESC-- 26、查询每门课程被选修的学生数 select c_id,count(c_id) from score group by c_id -- 27、查询出只有两门课程的全部学生的学号和姓名 select s_id,s_name from student where s_id in (select s_id from score group by s_id having count(c_id) = 2)-- 28、查询男生、女生人数 select s_sex,COUNT(s_sex) as 人数 from student GROUP BY s_sex-- 29、查询名字中含有&quot;风&quot;字的学生信息 select * from student where s_name like &apos;%风%&apos;-- 30、查询同名同性学生名单，并统计同名人数 select a.s_name,a.s_sex,count(*) from student a JOIN student b on a.s_id !=b.s_id and a.s_name = b.s_name and a.s_sex = b.s_sex GROUP BY a.s_name,a.s_sex-- 31、查询1990年出生的学生名单 select s_name from student where s_birth like &apos;1990%&apos;-- 32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 select c_id,avg(s_score) as 平均成绩 from score group by c_id order by 平均成绩 desc,c_id asc-- 33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩 SELECT A.S_ID,A.S_NAME,AVG(B.S_SCORE) AS 平均成绩 FROM STUDENT A LEFT JOIN SCORE B ON A.S_ID =B.S_ID GROUP BY S_ID HAVING AVG(B.S_SCORE)&gt;=85-- 34、查询课程名称为&quot;数学&quot;，且分数低于60的学生姓名和分数 select a.s_name,b.s_score from student a left join score b on a.s_id = b.s_id where b.s_score &lt; 60 group by a.s_id -- 可能会出现 [Err] 1055 的错误 只需在my.ini中[mysqld]加入sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;-- 35、查询所有学生的课程及分数情况 --第一种不直观 SELECT a.s_id,b.c_id,a.s_score FROM score a LEFT JOIN course b on a.c_id =b.c_id select a.s_id,a.s_name, SUM(case c.c_name when &apos;语文&apos; then b.s_score else 0 end) as &apos;语文&apos;, SUM(case c.c_name when &apos;数学&apos; then b.s_score else 0 end) as &apos;数学&apos;, SUM(case c.c_name when &apos;英语&apos; then b.s_score else 0 end) as &apos;英语&apos;, SUM(b.s_score) as &apos;总分&apos; from student a left join score b on a.s_id = b.s_id left join course c on b.c_id = c.c_id GROUP BY a.s_id,a.s_name -- 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数 select a.s_name,c.c_name,b.s_score from student a left join score b on a.s_id =b.s_id left join course c on b.c_id =c.c_id where b.s_score &gt; 70-- 37、查询不及格的课程 select a.s_id,a.c_id,b.c_name,a.s_score from score a left join course b on a.c_id = b.c_id where a.s_score&lt;60 --38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名 select s_id,s_name from student where s_id in (select s_id from score where c_id =&apos;01&apos; and s_score &gt; 80 ) -- 39、求每门课程的学生人数 select c_id,count(c_id) from score group by c_id-- 40、查询选修&quot;张三&quot;老师所授课程的学生中，成绩最高的学生信息及其成绩 select a.*,b.s_score,b.c_id,c.c_name from student a LEFT JOIN score b on a.s_id = b.s_id LEFT JOIN course c on b.c_id=c.c_id where b.c_id =(select c_id from course c,teacher d where c.t_id=d.t_id and d.t_name=&apos;张三&apos;) and b.s_score = (select MAX(s_score) from score where c_id=(select c_id from course c,teacher d where c.t_id=d.t_id and d.t_name=&apos;张三&apos;))-- 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 --第一种 SELECT * FROM score a WHERE (SELECT count(*) FROM score b WHERE b.c_id = a.c_id AND b.s_score &gt; a.s_score) &lt;= 1 --第二种 select a.s_id,a.c_id,a.s_score from score a where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score&gt;=a.s_score)&lt;=2 ORDER BY a.c_id-- 42、查询每门功成绩最好的前两名 -- 牛逼的写法 select a.s_id,a.c_id,a.s_score from score a where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score&gt;=a.s_score)&lt;=2 ORDER BY a.c_id-- 43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 select c_id,count(*) as total from score GROUP BY c_id HAVING total&gt;5 ORDER BY total,c_id ASC-- 44、检索至少选修两门课程的学生学号 select s_id from score group by s_id having count(s_id) &gt;1-- 45、查询选修了全部课程的学生信息 select * from student where s_id in (select s_id from score group by s_id having count(*) =(select count(*) from course))--46、查询各学生的年龄 -- 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一 select s_birth,(DATE_FORMAT(NOW(),&apos;%Y&apos;)-DATE_FORMAT(s_birth,&apos;%Y&apos;) - (case when DATE_FORMAT(NOW(),&apos;%m%d&apos;)&gt;DATE_FORMAT(s_birth,&apos;%m%d&apos;) then 0 else 1 end)) as age from student;-- 47、查询本周过生日的学生 select * from student where WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))=WEEK(s_birth) select * from student where YEARWEEK(s_birth)=YEARWEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;)) select WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))-- 48、查询下周过生日的学生 select * from student where WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))+1 =WEEK(s_birth)-- 49、查询本月过生日的学生 select * from student where MONTH(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;)) =MONTH(s_birth)-- 50、查询下月过生日的学生 select * from student where MONTH(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))+1 =MONTH(s_birth)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://Chankin026.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://Chankin026.github.io/tags/Mysql/"}]},{"title":"整理一些学习过的数据结构和算法blog","slug":"整理一些学习过的数据结构和算法blog","date":"2018-09-28T03:39:39.000Z","updated":"2018-09-28T15:59:45.879Z","comments":true,"path":"2018/09/28/整理一些学习过的数据结构和算法blog/","link":"","permalink":"https://Chankin026.github.io/2018/09/28/整理一些学习过的数据结构和算法blog/","excerpt":"","text":"树形结构:二叉查找树 二叉查找树之 Java的实现 二叉搜索树Java实现（查找、插入、删除、遍历） - Michaelwjw - 博客园 AVL树的设计与实现 - CSDN博客 彻底搞懂AVL树 - 简书 AVL树(三)之 Java的实现 - 如果天空不死 - 博客园 红黑树(一)之 原理和算法详细介绍 红黑树(五)之 Java的实现 查找（一）史上最简单清晰的红黑树讲解 - CSDN博客 !最容易懂得红黑树 - CSDN博客 查找（一）史上最简单清晰的红黑树讲解 - CSDN博客 查找树（2-3-4 树） - 匠心十年- 博客园 图的遍历之 深度优先搜索和广度优先搜索 哈夫曼树(三)之 Java详解 从B树、B+树、B*树谈到R 树 Trie树详解及其应用 数据结构与算法中，树一般会应用在哪些方面？为什么？ - 知乎 算法系列:8大排序:冒泡排序 快速排序 直接插入排序 希尔排序 选择排序 堆排序 桶排序 基数排序 其他基础算法:递归之斐波那契数列java的三种写法- CSDN博客 8皇后以及N皇后算法探究，回溯算法的JAVA实现，递归方案 分治归并排序算法——Java实现- CSDN博客 java-贪心算法 【贪心法求解最小生成树之Kruskal算法详细分析】—Greedy Algorithm for MST Prim算法(三)之 Java详解 Dijkstra算法(三)之Java详解- 如果天空不死- 博客园 并发编程:海子大神系列: Java并发编程：进程和线程之由来 Java并发编程：如何创建线程？ Java并发编程：Thread类的使用 Java并发编程：线程间协作的两种方式：wait、notify、notifyAll和Condition Java并发编程：synchronized Java并发编程：Lock Java并发编程：volatile关键字解析 Java并发编程：深入剖析ThreadLocal Java并发编程：同步容器 Java ConcurrentModificationException异常原因和解决方法 Java并发编程：并发容器之ConcurrentHashMap（转载） Java并发编程：并发容器之CopyOnWriteArrayList（转载） Java并发编程：阻塞队列 Java并发编程：线程池的使用 Java并发编程：CountDownLatch、CyclicBarrier和Semaphore Java并发编程：Callable、Future和FutureTask Java并发编程：Timer和TimerTask（转载） skywang大神系列:(一) 基础篇 Java多线程系列–“基础篇”01之 基本概念 Java多线程系列–“基础篇”02之 常用的实现多线程的两种方式 Java多线程系列–“基础篇”03之 Thread中start()和run()的区别 Java多线程系列–“基础篇”04之 synchronized关键字 Java多线程系列–“基础篇”05之 线程等待与唤醒 Java多线程系列–“基础篇”06之 线程让步 Java多线程系列–“基础篇”07之 线程休眠 Java多线程系列–“基础篇”08之 join() Java多线程系列–“基础篇”09之 interrupt()和线程终止方式 Java多线程系列–“基础篇”10之 线程优先级和守护线程 Java多线程系列–“基础篇”11之 生产消费者问题 (二) JUC原子类 Java多线程系列–“JUC原子类”01之 框架 Java多线程系列–“JUC原子类”02之 AtomicLong原子类 Java多线程系列–“JUC原子类”03之 AtomicLongArray原子类 Java多线程系列–“JUC原子类”04之 AtomicReference原子类 Java多线程系列–“JUC原子类”05之 AtomicLongFieldUpdater原子类 (三) JUC锁 Java多线程系列–“JUC锁”01之 框架 Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock Java多线程系列–“JUC锁”03之 公平锁(一) Java多线程系列–“JUC锁”04之 公平锁(二) Java多线程系列–“JUC锁”05之 非公平锁 Java多线程系列–“JUC锁”06之 Condition条件 Java多线程系列–“JUC锁”07之 LockSupport Java多线程系列–“JUC锁”08之 共享锁和ReentrantReadWriteLock Java多线程系列–“JUC锁”09之 CountDownLatch原理和示例 Java多线程系列–“JUC锁”10之 CyclicBarrier原理和示例 Java多线程系列–“JUC锁”11之 Semaphore信号量的原理和示例 (四) JUC集合 Java多线程系列–“JUC集合”01之 框架 Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet Java多线程系列–“JUC集合”04之 ConcurrentHashMap Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap Java多线程系列–“JUC集合”06之 ConcurrentSkipListSet Java多线程系列–“JUC集合”07之 ArrayBlockingQueue Java多线程系列–“JUC集合”08之 LinkedBlockingQueue Java多线程系列–“JUC集合”09之 LinkedBlockingDeque Java多线程系列–“JUC集合”10之 ConcurrentLinkedQueue (五) JUC线程池 Java多线程系列–“JUC线程池”01之 线程池架构 Java多线程系列–“JUC线程池”02之 线程池原理(一) Java多线程系列–“JUC线程池”03之 线程池原理(二) Java多线程系列–“JUC线程池”04之 线程池原理(三) Java多线程系列–“JUC线程池”05之 线程池原理(四) Java多线程系列–“JUC线程池”06之 Callable和Future 附加内容《深入理解Java内存模型》读书总结 深入浅出ThreadLocal - Java综合 - Java - ITeye论坛 ThreadLocal-面试必问深度解析 - 简书 面试集合:Java线程面试题 Top 50 （转载） JAVA多线程和并发基础面试问答（转载） IO/IP HTTP TCP:HTTP2和HTTPS来不来了解一下？ - 掘金 Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码） - CSDN博客 TCP协议详解 - Red_Code - 博客园 基础笔记（三）：网络协议之Tcp、Http - 老真 - 博客园 【NIO引入】BIO、AIO与NIO的区别 - CSDN博客 Java NIO：浅析I/O模型 书籍: 如果有人让你推荐前端技术书，请让他看这个列表 - WEB前端 - 伯乐在线 JAVA程序员必看的15本书-JAVA自学书籍推荐 （转） - CSDN博客 干货 ｜ 推荐五本国外最受欢迎的Spring教程书","categories":[{"name":"算法","slug":"算法","permalink":"https://Chankin026.github.io/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://Chankin026.github.io/categories/算法/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Chankin026.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Chankin026.github.io/tags/算法/"},{"name":"收藏","slug":"收藏","permalink":"https://Chankin026.github.io/tags/收藏/"},{"name":"并发","slug":"并发","permalink":"https://Chankin026.github.io/tags/并发/"}]},{"title":"解析Tomcat内部结构和请求过程","slug":"解析Tomcat内部结构和请求过程","date":"2018-09-27T16:52:19.000Z","updated":"2018-09-28T09:45:32.076Z","comments":true,"path":"2018/09/28/解析Tomcat内部结构和请求过程/","link":"","permalink":"https://Chankin026.github.io/2018/09/28/解析Tomcat内部结构和请求过程/","excerpt":"","text":"","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://Chankin026.github.io/categories/Tomcat/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://Chankin026.github.io/tags/Tomcat/"}]},{"title":"Typora的简单使用","slug":"Typora的简单使用","date":"2018-09-27T03:00:00.000Z","updated":"2018-09-28T10:23:23.894Z","comments":true,"path":"2018/09/27/Typora的简单使用/","link":"","permalink":"https://Chankin026.github.io/2018/09/27/Typora的简单使用/","excerpt":"","text":"Typora是一款超简洁的markdown编辑器，具有如下特点： 完全免费，目前已支持中文 跨平台，支持windows,mac,linux 支持数学公式输入，图片插入 极其简洁，无多余功能 界面所见即所得 区域元素YAML FONT Matters在文章最上方输入---，按换行键产生，输入内容即可 菜单输入+换行键，产生标题，自动更新 1[toc] + 回车键 段落按换行键建立新的一行可在行尾插入打断线，禁止向后插入 1按换行键建立新的一行&lt;br/&gt; 标题开头#的个数表示，空格+文字。标题有1~6个级别，#表示开始，按换行键结束 123# H1## H2###### H6 引注开头&gt;表示，空格+文字，按换行键换行，双按换行跳出 123&gt; ni&gt;&gt; ni hao ni nini 序列开头* + -，空格+文字，可以创建无序序列，换行键换行，删除键+shift+tab跳出 开头1.，空格+后接文字，可以创建有序序列 1234567* Red+ Green- Blue1. Red2. Green3. Blue 无序序列 你 可选序列开头序列+空格+[ ]+空格+文字，换行键换行，删除键+shift+tab跳出 1234- [ ] a+ [ ] b* [ ] c- [x] completed [x] a [x] b [x] c [x] d 代码块1234​```javapublic class test&#123;&#125;``` 数学块使用MtathJax建立数学公式 开头$$+换行键，产生输入区域， 输入Tex/LaTex格式的数学公式 1234567$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125;\\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\end&#123;vmatrix&#125;$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$ 表格开头| 列名 | 列名 | 换行键，创建一个2*2表格 将鼠标放置其上，弹出编辑尺寸，个数，文字等 1234|第一列|第二列| 第三列||:----|:----:|----:||左对齐|居中|右对齐| 第一列 第二列 第三列 左对齐 居中 右对齐 居左：:---- 居中：:----:或----- 居右：----: 脚注12脚注产生的方法[^footnote].[^footnote]: *这个就是脚注* 脚注产生的方法^1 水平线输入***/—，换行键换行 12***--- 特征元素链接单击链接，展开后可编辑 ctr+单击，打开链接 超链接用[]括住要超链接的内容，紧接着用()括住超链接源+名字，超链接源后面+超链接命名 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. This is an example inline link. This link has no title attribute. 内链接相关链使用 [超链接文字]+[标签]，创建可定义链接 12345This is [an example][id] reference-style link.Then, anywhere in the document, you define your link label like this, on a line by itself:[id]: http://example.com/ &quot;Optional Title Here&quot; BaiduAnd then define the link: GoogleAnd then define the link: URLs用&lt;&gt;括住url，可手动设置url 对于标准URLs，可自动识别 12&lt;chanjian1261@gmail.com&gt;www.baidu.com chanjian1261@gmail.com www.google.com 图片 手动添加：类似链接，前面需加！ 用鼠标拖图片进入，然后鼠标放置其上修改 12![V2EX](https://upload.wikimedia.org/wikipedia/commons/e/ed/V2ex.png)![Github](https://cdn2.iconfinder.com/data/icons/black-white-social-media/64/social_media_logo_github-128.png) V2EX Github 斜体以*或__括住 123*single asterisks*_single underscores_ single asterisks single underscores 加粗开头双*或双，结尾双*或双，建议双* 123**double asterisks**__double underscores__ double asterisks double underscores 删除线用两个~开头，两个~结尾 1~~Mistaken text.~~ 错误文字. 下划线使用HTML标签 1&lt;u&gt;Underline&lt;/u&gt; Underline 代码用两个`在正常段落总表示代码 1Use t he `printf()` function. Use the printf() function. 数学式需 Preference Panel -&gt; Markdown Tab启动， 输入$，然后按ESC键，之后输入Tex命令，可预览 1$\\lim_&#123;x\\to\\infty&#125;\\exp(-x)=0$ $\\lim_{x\\to\\infty}\\exp(-x)=0$ 上下标123H&lt;sub&gt;2&lt;/sub&gt;O CO&lt;sub&gt;2&lt;/sub&gt;爆米&lt;sup&gt;TM&lt;/sup&gt; H2OCO2爆米TM 高亮需 Preference Panel -&gt; Markdown Tab启动， 使用双==括住内容, 或者利用html 的mark标签 12==highlight==&lt;mark&gt;highlight&lt;/mark&gt; highlight","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://Chankin026.github.io/categories/Markdown/"},{"name":"Typora","slug":"Markdown/Typora","permalink":"https://Chankin026.github.io/categories/Markdown/Typora/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://Chankin026.github.io/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://Chankin026.github.io/tags/Typora/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-31T17:00:00.000Z","updated":"2018-09-28T09:16:30.681Z","comments":true,"path":"2018/09/01/hello-world/","link":"","permalink":"https://Chankin026.github.io/2018/09/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://Chankin026.github.io/categories/Hexo/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://Chankin026.github.io/tags/HTML/"}]}]}