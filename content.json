{"meta":{"title":"Chankin's Blogs","subtitle":"-记录学习和总结过程-","description":"Grasp All,Lose All.","author":"Chankin","url":"https://chankin026.github.io"},"pages":[{"title":"About","date":"2018-09-27T12:01:10.000Z","updated":"2018-09-27T12:18:22.958Z","comments":true,"path":"About/index.html","permalink":"https://chankin026.github.io/About/index.html","excerpt":"","text":"Java 都十分骄傲了圣诞节了"},{"title":"Tags","date":"2018-09-27T11:58:34.000Z","updated":"2018-09-27T17:28:44.696Z","comments":false,"path":"tags/index.html","permalink":"https://chankin026.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-09-27T12:16:47.000Z","updated":"2018-09-27T17:28:58.117Z","comments":false,"path":"categories/index.html","permalink":"https://chankin026.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"sql语句练习51题","slug":"sql语句练习51题","date":"2018-09-28T13:13:45.000Z","updated":"2018-09-28T13:36:43.874Z","comments":true,"path":"2018/09/28/sql语句练习51题/","link":"","permalink":"https://chankin026.github.io/2018/09/28/sql语句练习51题/","excerpt":"","text":"&emsp;&emsp; 习题来源于网络，难度会稍高, sql语句是一部分自己写的，一部分是参考的(前23题当时没保存,直接拷贝原博)。其中有很多大神的牛逼写法,也有我自己比较差劲的写法。 源自: sql语句练习50题(Mysql版)CSDN博客 表名和字段 学生表 : Student(s_id,s_name,s_birth,s_sex) – –学生编号,学生姓名, 出生年月,学生性别 课程表 :Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号 教师表:Teacher(t_id,t_name) – –教师编号,教师姓名 成绩表Score(s_id,c_id,s_score) – – 学生编号,课程编号,分数 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--建表--学生表CREATE TABLE `Student`(`s_id` VARCHAR(20),`s_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`s_birth` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`s_sex` VARCHAR(10) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY(`s_id`));--课程表CREATE TABLE `Course`(`c_id` VARCHAR(20),`c_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,`t_id` VARCHAR(20) NOT NULL,PRIMARY KEY(`c_id`));--教师表CREATE TABLE `Teacher`(`t_id` VARCHAR(20),`t_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY(`t_id`));--成绩表CREATE TABLE `Score`(`s_id` VARCHAR(20),`c_id` VARCHAR(20),`s_score` INT(3),PRIMARY KEY(`s_id`,`c_id`));--插入学生表测试数据insert into Student values(&apos;01&apos; , &apos;赵雷&apos; , &apos;1990-01-01&apos; , &apos;男&apos;);insert into Student values(&apos;02&apos; , &apos;钱电&apos; , &apos;1990-12-21&apos; , &apos;男&apos;);insert into Student values(&apos;03&apos; , &apos;孙风&apos; , &apos;1990-05-20&apos; , &apos;男&apos;);insert into Student values(&apos;04&apos; , &apos;李云&apos; , &apos;1990-08-06&apos; , &apos;男&apos;);insert into Student values(&apos;05&apos; , &apos;周梅&apos; , &apos;1991-12-01&apos; , &apos;女&apos;);insert into Student values(&apos;06&apos; , &apos;吴兰&apos; , &apos;1992-03-01&apos; , &apos;女&apos;);insert into Student values(&apos;07&apos; , &apos;郑竹&apos; , &apos;1989-07-01&apos; , &apos;女&apos;);insert into Student values(&apos;08&apos; , &apos;王菊&apos; , &apos;1990-01-20&apos; , &apos;女&apos;);--课程表测试数据insert into Course values(&apos;01&apos; , &apos;语文&apos; , &apos;02&apos;);insert into Course values(&apos;02&apos; , &apos;数学&apos; , &apos;01&apos;);insert into Course values(&apos;03&apos; , &apos;英语&apos; , &apos;03&apos;);--教师表测试数据insert into Teacher values(&apos;01&apos; , &apos;张三&apos;);insert into Teacher values(&apos;02&apos; , &apos;李四&apos;);insert into Teacher values(&apos;03&apos; , &apos;王五&apos;);--成绩表测试数据insert into Score values(&apos;01&apos; , &apos;01&apos; , 80);insert into Score values(&apos;01&apos; , &apos;02&apos; , 90);insert into Score values(&apos;01&apos; , &apos;03&apos; , 99);insert into Score values(&apos;02&apos; , &apos;01&apos; , 70);insert into Score values(&apos;02&apos; , &apos;02&apos; , 60);insert into Score values(&apos;02&apos; , &apos;03&apos; , 80);insert into Score values(&apos;03&apos; , &apos;01&apos; , 80);insert into Score values(&apos;03&apos; , &apos;02&apos; , 80);insert into Score values(&apos;03&apos; , &apos;03&apos; , 80);insert into Score values(&apos;04&apos; , &apos;01&apos; , 50);insert into Score values(&apos;04&apos; , &apos;02&apos; , 30);insert into Score values(&apos;04&apos; , &apos;03&apos; , 20);insert into Score values(&apos;05&apos; , &apos;01&apos; , 76);insert into Score values(&apos;05&apos; , &apos;02&apos; , 87);insert into Score values(&apos;06&apos; , &apos;01&apos; , 31);insert into Score values(&apos;06&apos; , &apos;03&apos; , 34);insert into Score values(&apos;07&apos; , &apos;02&apos; , 89);insert into Score values(&apos;07&apos; , &apos;03&apos; , 98); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381-- * 查询每门课程选修的同学信息SELECT a.*, b.c_id FROM student a RIGHT JOIN score b ON a.s_id = b.s_id WHERE b.c_id in( SELECT c.c_id FROM score c GROUP BY c.c_id HAVING count(*)) order by c_id;-- 1、查询&quot;01&quot;课程比&quot;02&quot;课程成绩高的学生的信息及课程分数 select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a join score b on a.s_id=b.s_id and b.c_id=&apos;01&apos; left join score c on a.s_id=c.s_id and c.c_id=&apos;02&apos; or c.c_id = NULL where b.s_score&gt;c.s_score-- 2、查询&quot;01&quot;课程比&quot;02&quot;课程成绩低的学生的信息及课程分数select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a left join score b on a.s_id=b.s_id and b.c_id=&apos;01&apos; or b.c_id=NULL join score c on a.s_id=c.s_id and c.c_id=&apos;02&apos; where b.s_score&lt;c.s_score-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b join score a on b.s_id = a.s_id GROUP BY b.s_id,b.s_name HAVING ROUND(AVG(a.s_score),2)&gt;=60;-- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩 -- (包括有成绩的和无成绩的)select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b left join score a on b.s_id = a.s_id GROUP BY b.s_id,b.s_name HAVING ROUND(AVG(a.s_score),2)&lt;60 unionselect a.s_id,a.s_name,0 as avg_score from student a where a.s_id not in ( select distinct s_id from score);-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩select a.s_id,a.s_name,count(b.c_id) as sum_course,sum(b.s_score) as sum_score from student a left join score b on a.s_id=b.s_id GROUP BY a.s_id,a.s_name;-- 6、查询&quot;李&quot;姓老师的数量 select count(t_id) from teacher where t_name like &apos;李%&apos;;-- 7、查询学过&quot;张三&quot;老师授课的同学的信息 select a.* from student a join score b on a.s_id=b.s_id where b.c_id in( select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;));-- 8、查询没学过&quot;张三&quot;老师授课的同学的信息 select * from student c where c.s_id not in( select a.s_id from student a join score b on a.s_id=b.s_id where b.c_id in( select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;)))-- 9、查询学过编号为&quot;01&quot;并且也学过编号为&quot;02&quot;的课程的同学的信息select a.* from student a,score b,score c where a.s_id = b.s_id and a.s_id = c.s_id and b.c_id=&apos;01&apos; and c.c_id=&apos;02&apos;;-- 10、查询学过编号为&quot;01&quot;但是没有学过编号为&quot;02&quot;的课程的同学的信息select a.* from student a where a.s_id in (select s_id from score where c_id=&apos;01&apos; ) and a.s_id not in(select s_id from score where c_id=&apos;02&apos;)-- 11、查询没有学全所有课程的同学的信息 --第一种 select s.* from student s where s.s_id in( select s_id from score where s_id not in( select a.s_id from score a join score b on a.s_id = b.s_id and b.c_id=&apos;02&apos; join score c on a.s_id = c.s_id and c.c_id=&apos;03&apos; where a.c_id=&apos;01&apos;)) --第二种 SELECT a.* FROM student a RIGHT JOIN (SELECT s_id, count(*) FROM score GROUP BY s_id HAVING count(c_id) &lt; (SELECT count(*) FROM course)) AS b ON a.s_id = b.s_id -- 12、查询至少有一门课与学号为&quot;01&quot;的同学所学相同的同学的信息 select * from student where s_id in( select distinct a.s_id from score a where a.c_id in(select a.c_id from score a where a.s_id=&apos;01&apos;) )-- 13、查询和&quot;01&quot;号的同学学习的课程完全相同的其他同学的信息 select a.* from student a where a.s_id in( select distinct s_id from score where s_id!=&apos;01&apos; and c_id in(select c_id from score where s_id=&apos;01&apos;) group by s_id having count(1)=(select count(1) from score where s_id=&apos;01&apos;));-- 14、查询没学过&quot;张三&quot;老师讲授的任一门课程的学生姓名 select a.s_name from student a where a.s_id not in ( select s_id from score where c_id = (select c_id from course where t_id =( select t_id from teacher where t_name = &apos;张三&apos;)) group by s_id);-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 select a.s_id,a.s_name,ROUND(AVG(b.s_score)) from student a left join score b on a.s_id = b.s_id where a.s_id in( select s_id from score where s_score&lt;60 GROUP BY s_id having count(1)&gt;=2) GROUP BY a.s_id,a.s_name-- 16、检索&quot;01&quot;课程分数小于60，按分数降序排列的学生信息select a.*,b.c_id,b.s_score from student a,score b where a.s_id = b.s_id and b.c_id=&apos;01&apos; and b.s_score&lt;60 ORDER BY b.s_score DESC;-- 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩select a.s_id,(select s_score from score where s_id=a.s_id and c_id=&apos;01&apos;) as 语文, (select s_score from score where s_id=a.s_id and c_id=&apos;02&apos;) as 数学, (select s_score from score where s_id=a.s_id and c_id=&apos;03&apos;) as 英语, round(avg(s_score),2) as 平均分 from score a GROUP BY a.s_id ORDER BY 平均分 DESC;-- 18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率--及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90select a.c_id,b.c_name,MAX(s_score),MIN(s_score),ROUND(AVG(s_score),2), ROUND(100*(SUM(case when a.s_score&gt;=60 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 及格率, ROUND(100*(SUM(case when a.s_score&gt;=70 and a.s_score&lt;=80 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 中等率, ROUND(100*(SUM(case when a.s_score&gt;=80 and a.s_score&lt;=90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 优良率, ROUND(100*(SUM(case when a.s_score&gt;=90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end)),2) as 优秀率 from score a left join course b on a.c_id = b.c_id GROUP BY a.c_id,b.c_name-- 19、按各科成绩进行排序，并显示排名(实现不完全)-- mysql没有rank函数 select a.s_id,a.c_id, @i:=@i +1 as i保留排名, @k:=(case when @score=a.s_score then @k else @i end) as rank不保留排名, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;01&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s union select a.s_id,a.c_id, @i:=@i +1 as i, @k:=(case when @score=a.s_score then @k else @i end) as rank, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;02&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s union select a.s_id,a.c_id, @i:=@i +1 as i, @k:=(case when @score=a.s_score then @k else @i end) as rank, @score:=a.s_score as score from ( select s_id,c_id,s_score from score WHERE c_id=&apos;03&apos; GROUP BY s_id,c_id,s_score ORDER BY s_score DESC)a,(select @k:=0,@i:=0,@score:=0)s-- 20、查询学生的总成绩并进行排名 select a.s_id, @i:=@i+1 as i, @k:=(case when @score=a.sum_score then @k else @i end) as rank, @score:=a.sum_score as score from (select s_id,SUM(s_score) as sum_score from score GROUP BY s_id ORDER BY sum_score DESC)a, (select @k:=0,@i:=0,@score:=0)s-- 21、查询不同老师所教不同课程平均分从高到低显示 select a.t_id,c.t_name,a.c_id,ROUND(avg(s_score),2) as avg_score from course a left join score b on a.c_id=b.c_id left join teacher c on a.t_id=c.t_id GROUP BY a.c_id,a.t_id,c.t_name ORDER BY avg_score DESC;-- 22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩 select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@i:=@i+1 as 排名 from score a,(select @i:=0)s where a.c_id=&apos;01&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@j:=@j+1 as 排名 from score a,(select @j:=0)s where a.c_id=&apos;02&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3 UNION select d.*,c.排名,c.s_score,c.c_id from ( select a.s_id,a.s_score,a.c_id,@k:=@k+1 as 排名 from score a,(select @k:=0)s where a.c_id=&apos;03&apos; )c left join student d on c.s_id=d.s_id where 排名 BETWEEN 2 AND 3; -- 23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比 select distinct f.c_name,a.c_id,b.`85-100`,b.百分比,c.`70-85`,c.百分比,d.`60-70`,d.百分比,e.`0-60`,e.百分比 from score a LEFT JOIN (select c_id,sum(case when s_score &gt; 85 and s_score &lt;= 100 then 1 else 0 end) as `85-100`,100*(sum(case when s_score &gt; 85 and s_score &lt;= 100 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) b on a.c_id = b.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 70 and s_score &lt;= 85 then 1 else 0 end) as `70-85`,100*(sum(case when s_score &gt; 70 and s_score &lt;= 85 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) c on a.c_id = c.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 60 and s_score &lt;= 70 then 1 else 0 end) as `60-70`,100*(sum(case when s_score &gt; 60 and s_score &lt;= 70 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) d on a.c_id = d.c_id LEFT JOIN (select c_id,sum(case when s_score &gt; 0 and s_score &lt;= 60 then 1 else 0 end) as `0-60`,100*(sum(case when s_score &gt; 0 and s_score &lt;= 60 then 1 else 0 end)/count(*))as 百分比 from score group by c_id) e on a.c_id = e.c_id left join course f on a.c_id = f.c_id-- 24、查询学生平均成绩及其名次 SELECT a.s_id , @i :=@i+ 1 AS 名次 , @k := avg_s AS 平均分 FROM (SELECT s_id, avg(s_score) AS avg_s FROM score GROUP BY s_id) a, (SELECT @k := 0 ,@i := 0) b order by 平均分 desc -- 25、查询各科成绩前三名的记录 -- 1.选出b表比a表成绩大的所有组 -- 2.选出比当前id成绩大的 小于三个的 SELECT DISTINCT a.s_id, a.c_id,a.s_score FROM score a LEFT JOIN score b ON a.c_id = b.c_id AND a.s_score &lt; b.s_score GROUP BY a.s_id, a.c_id, a.s_score HAVING COUNT(a.s_id) &lt; 3 ORDER BY a.c_id,a.s_score DESC-- 26、查询每门课程被选修的学生数 select c_id,count(c_id) from score group by c_id -- 27、查询出只有两门课程的全部学生的学号和姓名 select s_id,s_name from student where s_id in (select s_id from score group by s_id having count(c_id) = 2)-- 28、查询男生、女生人数 select s_sex,COUNT(s_sex) as 人数 from student GROUP BY s_sex-- 29、查询名字中含有&quot;风&quot;字的学生信息 select * from student where s_name like &apos;%风%&apos;-- 30、查询同名同性学生名单，并统计同名人数 select a.s_name,a.s_sex,count(*) from student a JOIN student b on a.s_id !=b.s_id and a.s_name = b.s_name and a.s_sex = b.s_sex GROUP BY a.s_name,a.s_sex-- 31、查询1990年出生的学生名单 select s_name from student where s_birth like &apos;1990%&apos;-- 32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 select c_id,avg(s_score) as 平均成绩 from score group by c_id order by 平均成绩 desc,c_id asc-- 33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩 SELECT A.S_ID,A.S_NAME,AVG(B.S_SCORE) AS 平均成绩 FROM STUDENT A LEFT JOIN SCORE B ON A.S_ID =B.S_ID GROUP BY S_ID HAVING AVG(B.S_SCORE)&gt;=85-- 34、查询课程名称为&quot;数学&quot;，且分数低于60的学生姓名和分数 select a.s_name,b.s_score from student a left join score b on a.s_id = b.s_id where b.s_score &lt; 60 group by a.s_id -- 可能会出现 [Err] 1055 的错误 只需在my.ini中[mysqld]加入sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;-- 35、查询所有学生的课程及分数情况 --第一种不直观 SELECT a.s_id,b.c_id,a.s_score FROM score a LEFT JOIN course b on a.c_id =b.c_id select a.s_id,a.s_name, SUM(case c.c_name when &apos;语文&apos; then b.s_score else 0 end) as &apos;语文&apos;, SUM(case c.c_name when &apos;数学&apos; then b.s_score else 0 end) as &apos;数学&apos;, SUM(case c.c_name when &apos;英语&apos; then b.s_score else 0 end) as &apos;英语&apos;, SUM(b.s_score) as &apos;总分&apos; from student a left join score b on a.s_id = b.s_id left join course c on b.c_id = c.c_id GROUP BY a.s_id,a.s_name -- 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数 select a.s_name,c.c_name,b.s_score from student a left join score b on a.s_id =b.s_id left join course c on b.c_id =c.c_id where b.s_score &gt; 70-- 37、查询不及格的课程 select a.s_id,a.c_id,b.c_name,a.s_score from score a left join course b on a.c_id = b.c_id where a.s_score&lt;60 --38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名 select s_id,s_name from student where s_id in (select s_id from score where c_id =&apos;01&apos; and s_score &gt; 80 ) -- 39、求每门课程的学生人数 select c_id,count(c_id) from score group by c_id-- 40、查询选修&quot;张三&quot;老师所授课程的学生中，成绩最高的学生信息及其成绩 select a.*,b.s_score,b.c_id,c.c_name from student a LEFT JOIN score b on a.s_id = b.s_id LEFT JOIN course c on b.c_id=c.c_id where b.c_id =(select c_id from course c,teacher d where c.t_id=d.t_id and d.t_name=&apos;张三&apos;) and b.s_score = (select MAX(s_score) from score where c_id=(select c_id from course c,teacher d where c.t_id=d.t_id and d.t_name=&apos;张三&apos;))-- 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 --第一种 SELECT * FROM score a WHERE (SELECT count(*) FROM score b WHERE b.c_id = a.c_id AND b.s_score &gt; a.s_score) &lt;= 1 --第二种 select a.s_id,a.c_id,a.s_score from score a where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score&gt;=a.s_score)&lt;=2 ORDER BY a.c_id-- 42、查询每门功成绩最好的前两名 -- 牛逼的写法 select a.s_id,a.c_id,a.s_score from score a where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score&gt;=a.s_score)&lt;=2 ORDER BY a.c_id-- 43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 select c_id,count(*) as total from score GROUP BY c_id HAVING total&gt;5 ORDER BY total,c_id ASC-- 44、检索至少选修两门课程的学生学号 select s_id from score group by s_id having count(s_id) &gt;1-- 45、查询选修了全部课程的学生信息 select * from student where s_id in (select s_id from score group by s_id having count(*) =(select count(*) from course))--46、查询各学生的年龄 -- 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一 select s_birth,(DATE_FORMAT(NOW(),&apos;%Y&apos;)-DATE_FORMAT(s_birth,&apos;%Y&apos;) - (case when DATE_FORMAT(NOW(),&apos;%m%d&apos;)&gt;DATE_FORMAT(s_birth,&apos;%m%d&apos;) then 0 else 1 end)) as age from student;-- 47、查询本周过生日的学生 select * from student where WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))=WEEK(s_birth) select * from student where YEARWEEK(s_birth)=YEARWEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;)) select WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))-- 48、查询下周过生日的学生 select * from student where WEEK(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))+1 =WEEK(s_birth)-- 49、查询本月过生日的学生 select * from student where MONTH(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;)) =MONTH(s_birth)-- 50、查询下月过生日的学生 select * from student where MONTH(DATE_FORMAT(NOW(),&apos;%Y%m%d&apos;))+1 =MONTH(s_birth)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://chankin026.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://chankin026.github.io/tags/Mysql/"}]},{"title":"整理一些学习过的数据结构和算法blog","slug":"整理一些学习过的数据结构和算法blog","date":"2018-09-28T03:39:39.000Z","updated":"2018-09-28T15:39:32.480Z","comments":true,"path":"2018/09/28/整理一些学习过的数据结构和算法blog/","link":"","permalink":"https://chankin026.github.io/2018/09/28/整理一些学习过的数据结构和算法blog/","excerpt":"","text":"树形结构:二叉查找树 二叉查找树之 Java的实现 二叉搜索树Java实现（查找、插入、删除、遍历） - Michaelwjw - 博客园 AVL树的设计与实现 - CSDN博客 彻底搞懂AVL树 - 简书 AVL树(三)之 Java的实现 - 如果天空不死 - 博客园 红黑树(一)之 原理和算法详细介绍 红黑树(五)之 Java的实现 查找（一）史上最简单清晰的红黑树讲解 - CSDN博客 !最容易懂得红黑树 - CSDN博客 查找（一）史上最简单清晰的红黑树讲解 - CSDN博客 查找树（2-3-4 树） - 匠心十年- 博客园 图的遍历之 深度优先搜索和广度优先搜索 哈夫曼树(三)之 Java详解 从B树、B+树、B*树谈到R 树 Trie树详解及其应用 数据结构与算法中，树一般会应用在哪些方面？为什么？ - 知乎 算法系列:8大排序:冒泡排序 快速排序 直接插入排序 希尔排序 选择排序 堆排序 桶排序 基数排序 其他基础算法:递归之斐波那契数列java的三种写法- CSDN博客 8皇后以及N皇后算法探究，回溯算法的JAVA实现，递归方案 分治归并排序算法——Java实现- CSDN博客 java-贪心算法 【贪心法求解最小生成树之Kruskal算法详细分析】—Greedy Algorithm for MST Prim算法(三)之 Java详解 Dijkstra算法(三)之Java详解- 如果天空不死- 博客园 并发编程:海子大神系列: Java并发编程：进程和线程之由来 Java并发编程：如何创建线程？ Java并发编程：Thread类的使用 Java并发编程：线程间协作的两种方式：wait、notify、notifyAll和Condition Java并发编程：synchronized Java并发编程：Lock Java并发编程：volatile关键字解析 Java并发编程：深入剖析ThreadLocal Java并发编程：同步容器 Java ConcurrentModificationException异常原因和解决方法 Java并发编程：并发容器之ConcurrentHashMap（转载） Java并发编程：并发容器之CopyOnWriteArrayList（转载） Java并发编程：阻塞队列 Java并发编程：线程池的使用 Java并发编程：CountDownLatch、CyclicBarrier和Semaphore Java并发编程：Callable、Future和FutureTask Java并发编程：Timer和TimerTask（转载） skywang大神系列:(一) 基础篇 Java多线程系列–“基础篇”01之 基本概念 Java多线程系列–“基础篇”02之 常用的实现多线程的两种方式 Java多线程系列–“基础篇”03之 Thread中start()和run()的区别 Java多线程系列–“基础篇”04之 synchronized关键字 Java多线程系列–“基础篇”05之 线程等待与唤醒 Java多线程系列–“基础篇”06之 线程让步 Java多线程系列–“基础篇”07之 线程休眠 Java多线程系列–“基础篇”08之 join() Java多线程系列–“基础篇”09之 interrupt()和线程终止方式 Java多线程系列–“基础篇”10之 线程优先级和守护线程 Java多线程系列–“基础篇”11之 生产消费者问题 (二) JUC原子类 Java多线程系列–“JUC原子类”01之 框架 Java多线程系列–“JUC原子类”02之 AtomicLong原子类 Java多线程系列–“JUC原子类”03之 AtomicLongArray原子类 Java多线程系列–“JUC原子类”04之 AtomicReference原子类 Java多线程系列–“JUC原子类”05之 AtomicLongFieldUpdater原子类 (三) JUC锁 Java多线程系列–“JUC锁”01之 框架 Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock Java多线程系列–“JUC锁”03之 公平锁(一) Java多线程系列–“JUC锁”04之 公平锁(二) Java多线程系列–“JUC锁”05之 非公平锁 Java多线程系列–“JUC锁”06之 Condition条件 Java多线程系列–“JUC锁”07之 LockSupport Java多线程系列–“JUC锁”08之 共享锁和ReentrantReadWriteLock Java多线程系列–“JUC锁”09之 CountDownLatch原理和示例 Java多线程系列–“JUC锁”10之 CyclicBarrier原理和示例 Java多线程系列–“JUC锁”11之 Semaphore信号量的原理和示例 (四) JUC集合 Java多线程系列–“JUC集合”01之 框架 Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet Java多线程系列–“JUC集合”04之 ConcurrentHashMap Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap Java多线程系列–“JUC集合”06之 ConcurrentSkipListSet Java多线程系列–“JUC集合”07之 ArrayBlockingQueue Java多线程系列–“JUC集合”08之 LinkedBlockingQueue Java多线程系列–“JUC集合”09之 LinkedBlockingDeque Java多线程系列–“JUC集合”10之 ConcurrentLinkedQueue (五) JUC线程池 Java多线程系列–“JUC线程池”01之 线程池架构 Java多线程系列–“JUC线程池”02之 线程池原理(一) Java多线程系列–“JUC线程池”03之 线程池原理(二) Java多线程系列–“JUC线程池”04之 线程池原理(三) Java多线程系列–“JUC线程池”05之 线程池原理(四) Java多线程系列–“JUC线程池”06之 Callable和Future 附加内容《深入理解Java内存模型》读书总结 深入浅出ThreadLocal - Java综合 - Java - ITeye论坛 ThreadLocal-面试必问深度解析 - 简书 面试集合:Java线程面试题 Top 50 （转载） JAVA多线程和并发基础面试问答（转载） IO/IP HTTP TCP:HTTP2和HTTPS来不来了解一下？ - 掘金 Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码） - CSDN博客 TCP协议详解 - Red_Code - 博客园 基础笔记（三）：网络协议之Tcp、Http - 老真 - 博客园 【NIO引入】BIO、AIO与NIO的区别 - CSDN博客 Java NIO：浅析I/O模型 书籍: 如果有人让你推荐前端技术书，请让他看这个列表 - WEB前端 - 伯乐在线 JAVA程序员必看的15本书-JAVA自学书籍推荐 （转） - CSDN博客 干货 ｜ 推荐五本国外最受欢迎的Spring教程书","categories":[{"name":"算法","slug":"算法","permalink":"https://chankin026.github.io/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://chankin026.github.io/categories/算法/数据结构/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"https://chankin026.github.io/tags/收藏/"},{"name":"算法","slug":"算法","permalink":"https://chankin026.github.io/tags/算法/"},{"name":"并发","slug":"并发","permalink":"https://chankin026.github.io/tags/并发/"},{"name":"数据结构","slug":"数据结构","permalink":"https://chankin026.github.io/tags/数据结构/"}]},{"title":"test","slug":"test","date":"2018-09-27T18:10:39.000Z","updated":"2018-09-28T09:47:43.752Z","comments":true,"path":"2018/09/28/test/","link":"","permalink":"https://chankin026.github.io/2018/09/28/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"解析Tomcat内部结构和请求过程","slug":"解析Tomcat内部结构和请求过程","date":"2018-09-27T16:52:19.000Z","updated":"2018-09-28T09:45:32.076Z","comments":true,"path":"2018/09/28/解析Tomcat内部结构和请求过程/","link":"","permalink":"https://chankin026.github.io/2018/09/28/解析Tomcat内部结构和请求过程/","excerpt":"","text":"","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://chankin026.github.io/categories/Tomcat/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://chankin026.github.io/tags/Tomcat/"}]},{"title":"Typora的简单使用","slug":"Typora的简单使用","date":"2018-09-27T03:00:00.000Z","updated":"2018-09-28T10:23:23.894Z","comments":true,"path":"2018/09/27/Typora的简单使用/","link":"","permalink":"https://chankin026.github.io/2018/09/27/Typora的简单使用/","excerpt":"","text":"Typora是一款超简洁的markdown编辑器，具有如下特点： 完全免费，目前已支持中文 跨平台，支持windows,mac,linux 支持数学公式输入，图片插入 极其简洁，无多余功能 界面所见即所得 区域元素YAML FONT Matters在文章最上方输入---，按换行键产生，输入内容即可 菜单输入+换行键，产生标题，自动更新 1[toc] + 回车键 段落按换行键建立新的一行可在行尾插入打断线，禁止向后插入 1按换行键建立新的一行&lt;br/&gt; 标题开头#的个数表示，空格+文字。标题有1~6个级别，#表示开始，按换行键结束 123# H1## H2###### H6 引注开头&gt;表示，空格+文字，按换行键换行，双按换行跳出 123&gt; ni&gt;&gt; ni hao ni nini 序列开头* + -，空格+文字，可以创建无序序列，换行键换行，删除键+shift+tab跳出 开头1.，空格+后接文字，可以创建有序序列 1234567* Red+ Green- Blue1. Red2. Green3. Blue 无序序列 你 可选序列开头序列+空格+[ ]+空格+文字，换行键换行，删除键+shift+tab跳出 1234- [ ] a+ [ ] b* [ ] c- [x] completed [x] a [x] b [x] c [x] d 代码块1234​```javapublic class test&#123;&#125;``` 数学块使用MtathJax建立数学公式 开头$$+换行键，产生输入区域， 输入Tex/LaTex格式的数学公式 1234567$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125;\\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\end&#123;vmatrix&#125;$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$ 表格开头| 列名 | 列名 | 换行键，创建一个2*2表格 将鼠标放置其上，弹出编辑尺寸，个数，文字等 1234|第一列|第二列| 第三列||:----|:----:|----:||左对齐|居中|右对齐| 第一列 第二列 第三列 左对齐 居中 右对齐 居左：:---- 居中：:----:或----- 居右：----: 脚注12脚注产生的方法[^footnote].[^footnote]: *这个就是脚注* 脚注产生的方法^1 水平线输入***/—，换行键换行 12***--- 特征元素链接单击链接，展开后可编辑 ctr+单击，打开链接 超链接用[]括住要超链接的内容，紧接着用()括住超链接源+名字，超链接源后面+超链接命名 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. This is an example inline link. This link has no title attribute. 内链接相关链使用 [超链接文字]+[标签]，创建可定义链接 12345This is [an example][id] reference-style link.Then, anywhere in the document, you define your link label like this, on a line by itself:[id]: http://example.com/ &quot;Optional Title Here&quot; BaiduAnd then define the link: GoogleAnd then define the link: URLs用&lt;&gt;括住url，可手动设置url 对于标准URLs，可自动识别 12&lt;chanjian1261@gmail.com&gt;www.baidu.com chanjian1261@gmail.com www.google.com 图片 手动添加：类似链接，前面需加！ 用鼠标拖图片进入，然后鼠标放置其上修改 12![V2EX](https://upload.wikimedia.org/wikipedia/commons/e/ed/V2ex.png)![Github](https://cdn2.iconfinder.com/data/icons/black-white-social-media/64/social_media_logo_github-128.png) V2EX Github 斜体以*或__括住 123*single asterisks*_single underscores_ single asterisks single underscores 加粗开头双*或双，结尾双*或双，建议双* 123**double asterisks**__double underscores__ double asterisks double underscores 删除线用两个~开头，两个~结尾 1~~Mistaken text.~~ 错误文字. 下划线使用HTML标签 1&lt;u&gt;Underline&lt;/u&gt; Underline 代码用两个`在正常段落总表示代码 1Use t he `printf()` function. Use the printf() function. 数学式需 Preference Panel -&gt; Markdown Tab启动， 输入$，然后按ESC键，之后输入Tex命令，可预览 1$\\lim_&#123;x\\to\\infty&#125;\\exp(-x)=0$ $\\lim_{x\\to\\infty}\\exp(-x)=0$ 上下标123H&lt;sub&gt;2&lt;/sub&gt;O CO&lt;sub&gt;2&lt;/sub&gt;爆米&lt;sup&gt;TM&lt;/sup&gt; H2OCO2爆米TM 高亮需 Preference Panel -&gt; Markdown Tab启动， 使用双==括住内容, 或者利用html 的mark标签 12==highlight==&lt;mark&gt;highlight&lt;/mark&gt; highlight","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://chankin026.github.io/categories/Markdown/"},{"name":"Typora","slug":"Markdown/Typora","permalink":"https://chankin026.github.io/categories/Markdown/Typora/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://chankin026.github.io/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://chankin026.github.io/tags/Typora/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-31T17:00:00.000Z","updated":"2018-09-28T09:16:30.681Z","comments":true,"path":"2018/09/01/hello-world/","link":"","permalink":"https://chankin026.github.io/2018/09/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chankin026.github.io/categories/Hexo/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://chankin026.github.io/tags/HTML/"}]}]}