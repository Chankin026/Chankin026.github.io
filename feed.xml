<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>chankin's Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 06 Feb 2019 02:24:04 +0800</pubDate>
    <lastBuildDate>Wed, 06 Feb 2019 02:24:04 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>mysql主从复制的理解和实现</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql的复制概念&quot; id=&quot;markdown-toc-mysql的复制概念&quot;&gt;Mysql的复制概念&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#mysql的binarylog&quot; id=&quot;markdown-toc-mysql的binarylog&quot;&gt;Mysql的binary—log&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mysql复制所解决的问题&quot; id=&quot;markdown-toc-mysql复制所解决的问题&quot;&gt;Mysql复制所解决的问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#主从复制原理&quot; id=&quot;markdown-toc-主从复制原理&quot;&gt;主从复制原理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#主从复制的优点&quot; id=&quot;markdown-toc-主从复制的优点&quot;&gt;主从复制的优点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#缺点&quot; id=&quot;markdown-toc-缺点&quot;&gt;缺点&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql主从同步的实现&quot; id=&quot;markdown-toc-mysql主从同步的实现&quot;&gt;MySQL主从同步的实现&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#配置master&quot; id=&quot;markdown-toc-配置master&quot;&gt;配置master&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#配置slave&quot; id=&quot;markdown-toc-配置slave&quot;&gt;配置slave&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#测试&quot; id=&quot;markdown-toc-测试&quot;&gt;测试&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#深入了解&quot; id=&quot;markdown-toc-深入了解&quot;&gt;深入了解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考地址&quot; id=&quot;markdown-toc-参考地址&quot;&gt;参考地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;mysql的复制概念&quot;&gt;Mysql的复制概念&lt;/h3&gt;

&lt;img src=&quot;/images/mysql1.png&quot; alt=&quot;1546356512911&quot; /&gt;

Mysql内置的复制功能是构建大型高可用高性能应用的基础。 允许将来自一个MySQL数据库（master）的数据复制到一个或多个MySQL数据库服务器( slave ), 它可以进行&lt;strong&gt;异步的复制&lt;/strong&gt;,并不需要永久的连接。

通过配置，可以复制所有的数据库，某个数据库和表。 而实现复制功能的关键在于开启mysql的二进制日志log-bin。

&lt;h4 id=&quot;mysql的binarylog&quot;&gt;Mysql的binary—log&lt;/h4&gt;

MySQL的二进制日志binlog可以说是MySQL最重要的日志，它记录了数据库的DDL和DML语句（除了查询语句），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。

​	&lt;em&gt;DDL主要用于&lt;/em&gt;create、alter、drop等*

​	&lt;em&gt;DML主要用于select、insert、update和delete数据&lt;/em&gt;

binlog日志包括两类文件：
1）二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件
2）二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了select)语句事件。

&lt;img src=&quot;/images/mysql2.png&quot; alt=&quot;binary-log&quot; /&gt;

&lt;h4 id=&quot;mysql复制所解决的问题&quot;&gt;Mysql复制所解决的问题&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1. 数据分布 (Data distribution )
    2. 负载均衡(load balancing)
    3. 数据备份(Backups) ，保证数据安全
    4. 高可用性和容错行(High availability and failover)
    5. 实现读写分离，缓解数据库压力
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;主从复制原理&quot;&gt;主从复制原理&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    master服务器将数据改变记录到binlog日志
  &lt;/li&gt;
  &lt;li&gt;
    salve服务器在一定时间间隔内探测master的binlog日志是否改变。

    1）如果改变,则I/O线程请求master二进制事件。

    2）同时master为每个I/O线程启动一个dump线程，用于向其发送二进制事件。

    3）slave将事件保存至本地的中继日志(relay log) 中。

    4）slave将启动SQL线程从中继日志(relay log) 读取二进制日志，在slave上回放。使得其数据和master保持一致。
  &lt;/li&gt;
  &lt;li&gt;
    最后I/O线程和SQL线程将进入睡眠状态，等待下一次探测。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;img src=&quot;/images/mysql3.png&quot; alt=&quot;过程&quot; /&gt;

Mysql复制的流程图如下：

&lt;img src=&quot;/images/mysql4.png&quot; alt=&quot;流程&quot; /&gt;

&lt;h4 id=&quot;主从复制的优点&quot;&gt;主从复制的优点&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;在从服务器实现查询，降低主服务器压力;（主库写，从库读，降压）&lt;/li&gt;
  &lt;li&gt;从主服务器中进行数据备份，避免备份期间影响主服务器服务;（确保数据安全）&lt;/li&gt;
  &lt;li&gt;当主服务器出现问题时，可以切换到从服务器。（提升性能）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;

复制是异步且串行化的, 复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。

&lt;h3 id=&quot;mysql主从同步的实现&quot;&gt;MySQL主从同步的实现&lt;/h3&gt;

我这里是windows加centos, 需要ping 互通 以及开放端口号

首先,尽量保持两个服务器上的mysql版本一致

将windos中配置为master服务器,CentOS为slave服务器

&lt;h4 id=&quot;配置master&quot;&gt;配置master&lt;/h4&gt;

需修改my.ini

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;mysqld]
&lt;span class=&quot;c&quot;&gt;# 添加生成记录文件位置&lt;/span&gt;
log-bin&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysql-bin
&lt;span class=&quot;c&quot;&gt;# 设置为master服务器&lt;/span&gt;
server-id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

重启mysql服务

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net stop/start mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

登录mysql

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;记录&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;和&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Postion&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;img src=&quot;/images/mysql5.png&quot; alt=&quot;记录&quot; /&gt;

创建并授权用户，后两个slave分别是用户名和密码

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;这里&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;为&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slaveip&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;地址&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;查询&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replication&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'chankin'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'192.168.2.108'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'chankin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;权限生效&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;privileges&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;配置slave&quot;&gt;配置slave&lt;/h4&gt;

修改vim /etc/my.cnf 配置文件

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 添加生成记录文件位置&lt;/span&gt;
log-bin&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysql-bin
&lt;span class=&quot;c&quot;&gt;# 设置为从服务器&lt;/span&gt;
server-id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

重启mysql服务

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl restart mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

配置同步参数，登陆mysql，输入如下信息：

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHANGE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TO&lt;/span&gt;
	 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASTER_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'192.168.2.100'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt;
	 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASTER_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'chankin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	                 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;同步账户名&lt;/span&gt;
	 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASTER_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'chankin1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;				 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;同步密码&lt;/span&gt;
	 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASTER_LOG_FILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mysql-bin.000002'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;从&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;服务器同步的日志文件&lt;/span&gt;
	 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASTER_LOG_POS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;762&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;						 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;日志的开始位置。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

启动slave并查看

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;启动从服务器复制功能&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;G&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;查看从服务器状态&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;img src=&quot;/images/mysql6.png&quot; alt=&quot;status&quot; /&gt;

Slave_IO_Running: connecting 说明没有配置成功

检查 发现密码错了,停止slave服务重新配置同步参数

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;停止复制&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;省略&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;G&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;再次检查&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;img src=&quot;/images/mysql7.png&quot; alt=&quot;status&quot; /&gt;

&lt;strong&gt;Slave_IO_Running: Yes 和 Slave_SQL_Running: Yes&lt;/strong&gt; 说明 主从同步配置成了。

&lt;h4 id=&quot;测试&quot;&gt;测试&lt;/h4&gt;

在master服务器上创建数据库-表  , 插入数据

slave上select就可查到了

具体略

&lt;h3 id=&quot;深入了解&quot;&gt;深入了解&lt;/h3&gt;

&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/6256603.html&quot;&gt;Mysql主从同步(1)-主从/主主环境部署梳理&lt;/a&gt;

&lt;h3 id=&quot;参考地址&quot;&gt;参考地址&lt;/h3&gt;

​	&lt;a href=&quot;https://www.cnblogs.com/kylinlin/p/5258719.html&quot;&gt;Mysql主从同步（复制）&lt;/a&gt;

​	&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/5907254.html&quot;&gt;Mysql之binlog日志说明及利用binlog日志恢复数据操作记录&lt;/a&gt;

​	&lt;a href=&quot;https://www.cnblogs.com/chhuang/p/4182868.html&quot;&gt;集群CLUSTER种类介绍&lt;/a&gt;
</description>
        <pubDate>Tue, 20 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/20/Mysql-replication/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/20/Mysql-replication/</guid>
        
        <category>Mysql</category>
        
        
        <category>Mysql</category>
        
      </item>
    
      <item>
        <title>Docker的入门</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#了解docker概念&quot; id=&quot;markdown-toc-了解docker概念&quot;&gt;了解Docker概念：&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#理解docker原理&quot; id=&quot;markdown-toc-理解docker原理&quot;&gt;理解Docker原理：&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#简单的运用docker&quot; id=&quot;markdown-toc-简单的运用docker&quot;&gt;简单的运用Docker&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#使用镜像&quot; id=&quot;markdown-toc-使用镜像&quot;&gt;使用镜像&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#拉取镜像&quot; id=&quot;markdown-toc-拉取镜像&quot;&gt;拉取镜像&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#运行镜像&quot; id=&quot;markdown-toc-运行镜像&quot;&gt;运行镜像&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;了解docker概念&quot;&gt;了解Docker概念：&lt;/h2&gt;

&lt;a href=&quot;http://dockone.io/article/6051&quot;&gt;可能是把Docker的概念讲的最清楚的一篇文章&lt;/a&gt;

&lt;h2 id=&quot;理解docker原理&quot;&gt;理解Docker原理：&lt;/h2&gt;

&lt;strong&gt;&lt;a href=&quot;http://dockone.io/article/783&quot;&gt;10张图带你深入理解Docker容器和镜像&lt;/a&gt;&lt;/strong&gt;
–大神级别文章,清晰地阐述了其存储原理及命令

&lt;strong&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/allen-docker-9153965.html&quot;&gt;Allen 谈 Docker 系列：&lt;/a&gt;&lt;/strong&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-9153976.html&quot;&gt;一图看尽 docker 容器文件系统&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-logs-9153967.html&quot;&gt;docker logs 实现剖析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-exec-9153970.html&quot;&gt;docker exec 与容器日志&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-9153973.html&quot;&gt;Docker 容器日志的那些事儿&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-9153979.html&quot;&gt;深刻理解 Docker 镜像大小&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-9153982.html&quot;&gt;Docker 镜像内有啥，存哪？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-json-9153985.html&quot;&gt;深入理解 Docker 镜像 json 文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-build-cache-9153988.html&quot;&gt;docker build 的 cache 机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-commit-9153991.html&quot;&gt;docker commit 的来龙去脉&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-root-9153994.html&quot;&gt;Docker 容器的 root 安全吗？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-9153997.html&quot;&gt;存储类 Docker 容器的明文密码问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guide.daocloud.io/dcs/docker-9154000.html&quot;&gt;Docker 容器明文密码问题解决之道&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;简单的运用docker&quot;&gt;简单的运用Docker&lt;/h2&gt;

安装：

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

安装好后启动docker：

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl start docker &lt;span class=&quot;c&quot;&gt;#启动docker stop restart 停止 重启&lt;/span&gt;
docker ‐v  
systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;docker &lt;span class=&quot;c&quot;&gt;#开机启动&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用镜像&quot;&gt;使用镜像&lt;/h2&gt;

&lt;h3 id=&quot;拉取镜像&quot;&gt;拉取镜像&lt;/h3&gt;

在docker hub上已经有很多现成的镜像了，只需要执行docker pull命令就可以拉取到本地：

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker search tomcat &lt;span class=&quot;c&quot;&gt;#搜索镜像 &lt;/span&gt;
docker pull tomcat   &lt;span class=&quot;c&quot;&gt;# 命令：docker pull 镜像名：[标签(版本)]  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

就这样，简单的一条命令就把tomcat运行环境的镜像pull到本地了，这里没有选取tomcat的版本，默认是latest。

查看本地镜像列表：

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker images &lt;span class=&quot;c&quot;&gt;#本地镜像列表&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;img src=&quot;https://raw.githubusercontent.com/objcoding/objcoding.github.io/master/images/docker.png&quot; alt=&quot;images&quot; /&gt;

&lt;h3 id=&quot;运行镜像&quot;&gt;运行镜像&lt;/h3&gt;

拉取镜像后，那么我们试着运行一下镜像：

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mytomcat &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8888:8080  tomcat   
&lt;span class=&quot;c&quot;&gt;# --name 指定名称&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 最后一个参数运行的镜像名&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#-d 后台运行 -p ‐p: 将主机的端口8888映射到容器的一个端口8080  &lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

常用的一些参数如下：

&lt;ul&gt;
  &lt;li&gt;
    -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；
  &lt;/li&gt;
  &lt;li&gt;
    -d: 后台运行容器，并返回容器ID；
  &lt;/li&gt;
  &lt;li&gt;
    -i: 以交互模式运行容器，通常与 -t 同时使用；
  &lt;/li&gt;
  &lt;li&gt;
    -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
  &lt;/li&gt;
  &lt;li&gt;
    –name=”nginx-lb”: 为容器指定一个名称；
  &lt;/li&gt;
  &lt;li&gt;
    –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；
  &lt;/li&gt;
  &lt;li&gt;
    –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；
  &lt;/li&gt;
  &lt;li&gt;
    -h “mars”: 指定容器的hostname；
  &lt;/li&gt;
  &lt;li&gt;
    -e username=”ritchie”: 设置环境变量；
  &lt;/li&gt;
  &lt;li&gt;
    –env-file=[]: 从指定文件读入环境变量；
  &lt;/li&gt;
  &lt;li&gt;
    –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；
  &lt;/li&gt;
  &lt;li&gt;
    -m :设置容器使用内存最大值；
  &lt;/li&gt;
  &lt;li&gt;
    –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
  &lt;/li&gt;
  &lt;li&gt;
    –link=[]: 添加链接到另一个容器；
  &lt;/li&gt;
  &lt;li&gt;
    –expose=[]: 开放一个端口或一组端口；
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 14 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/14/Docker(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/14/Docker(1)/</guid>
        
        <category>Docker</category>
        
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>RSA非对称加密的简单理解</title>
        <description>RSA是一种公开密钥算法。通常是通讯双方各成一对RSA公秘钥,公钥和私钥都可以用于加密和解密。其中私钥用户保存(不公开),公钥对外公开，任何人都可以获取。

假设A给B发送文本
RSA签名加密过程如下：

&lt;ol&gt;
  &lt;li&gt;B传递自己的公钥给A;&lt;/li&gt;
  &lt;li&gt;A对明文进行Hash运算得到信息摘要,用自己的私钥对摘要进行加密,形成数字签名, 同时使用B发送给A的公钥对明文加密,形成密文;&lt;/li&gt;
  &lt;li&gt;将密文和数字签名发送给B;&lt;/li&gt;
  &lt;li&gt;B收到 A发过来的签名和密文, 获得A的公钥对数字签名进行解签, 进行Hash运算得到信息摘要;&lt;/li&gt;
  &lt;li&gt;再用自己的私钥对进行解密,得到明文,对明文进行Hash运算得到信息摘要;&lt;/li&gt;
  &lt;li&gt;将两个摘要进行对比,两者一致则说明文本没有被篡改过。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 03 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/03/RSA/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/03/RSA/</guid>
        
        <category>RSA</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>CAP 定理的含义[转载]</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#cap-定理的含义&quot; id=&quot;markdown-toc-cap-定理的含义&quot;&gt;CAP 定理的含义&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#一分布式系统的三个指标&quot; id=&quot;markdown-toc-一分布式系统的三个指标&quot;&gt;一、分布式系统的三个指标&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#二partition-tolerance&quot; id=&quot;markdown-toc-二partition-tolerance&quot;&gt;二、Partition tolerance&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#三consistency&quot; id=&quot;markdown-toc-三consistency&quot;&gt;三、Consistency&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#四availability&quot; id=&quot;markdown-toc-四availability&quot;&gt;四、Availability&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#五consistency-和-availability-的矛盾&quot; id=&quot;markdown-toc-五consistency-和-availability-的矛盾&quot;&gt;五、Consistency 和 Availability 的矛盾&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

在学习redis 的时候不是很了解cap这个概念,从网上找到了阮一峰老师的文章,就转载过来了。  当然 阮老师 还有很多其他扫盲的文章,建议都看看

&lt;h1 id=&quot;cap-定理的含义&quot;&gt;CAP 定理的含义&lt;/h1&gt;

原文地址：http://www.ruanyifeng.com/blog/2018/07/cap.html

作者： &lt;a href=&quot;http://www.ruanyifeng.com/&quot;&gt;阮一峰&lt;/a&gt;

日期： &lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/07/&quot;&gt;2018年7月16日&lt;/a&gt;

分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。

分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。

本文介绍该定理。它其实很好懂，而且是显而易见的。下面的内容主要参考了 Michael Whittaker 的&lt;a href=&quot;https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/&quot;&gt;文章&lt;/a&gt;。

&lt;h2 id=&quot;一分布式系统的三个指标&quot;&gt;一、分布式系统的三个指标&lt;/h2&gt;

&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg&quot; alt=&quot;img&quot; /&gt;

1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Consistency&lt;/li&gt;
    &lt;li&gt;Availability&lt;/li&gt;
    &lt;li&gt;Partition tolerance&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

它们的第一个字母分别是 C、A、P。

Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。

&lt;h2 id=&quot;二partition-tolerance&quot;&gt;二、Partition tolerance&lt;/h2&gt;

先看 Partition tolerance，中文叫做”分区容错”。

大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。

&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png&quot; alt=&quot;img&quot; /&gt;

上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。

一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。

&lt;h2 id=&quot;三consistency&quot;&gt;三、Consistency&lt;/h2&gt;

Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。

&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201807/bg2018071602.png&quot; alt=&quot;img&quot; /&gt;

接下来，用户的读操作就会得到 v1。这就叫一致性。

&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201807/bg2018071603.png&quot; alt=&quot;img&quot; /&gt;

问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。

&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201807/bg2018071604.png&quot; alt=&quot;img&quot; /&gt;

为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。

&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201807/bg2018071605.png&quot; alt=&quot;img&quot; /&gt;

这样的话，用户向 G2 发起读操作，也能得到 v1。

&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201807/bg2018071606.png&quot; alt=&quot;img&quot; /&gt;

&lt;h2 id=&quot;四availability&quot;&gt;四、Availability&lt;/h2&gt;

Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。

用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。

&lt;h2 id=&quot;五consistency-和-availability-的矛盾&quot;&gt;五、Consistency 和 Availability 的矛盾&lt;/h2&gt;

一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。

如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。

如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。

&lt;strong&gt;综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。&lt;/strong&gt;

[更新 2018.7.17]

读者问，在什么场合，可用性高于一致性？

举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。

一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。

（完）
</description>
        <pubDate>Sat, 20 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/20/CAP/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/20/CAP/</guid>
        
        <category>CAP</category>
        
        <category>分布式</category>
        
        
        <category>Distributed</category>
        
      </item>
    
      <item>
        <title>继承HibernateDaoSupport实现CRUD</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#一获取hibernatetemplate&quot; id=&quot;markdown-toc-一获取hibernatetemplate&quot;&gt;一、获取HibernateTemplate()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二hibernate的三种查询方式&quot; id=&quot;markdown-toc-二hibernate的三种查询方式&quot;&gt;二、Hibernate的三种查询方式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#11-hqlhibernate-query-language&quot; id=&quot;markdown-toc-11-hqlhibernate-query-language&quot;&gt;1.1、 HQL（Hibernate Query Language）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#12-sqlstructured-query-language&quot; id=&quot;markdown-toc-12-sqlstructured-query-language&quot;&gt;1.2、 SQL（Structured Query Language）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#13-qbcquery-by-criteria&quot; id=&quot;markdown-toc-13-qbcquery-by-criteria&quot;&gt;1.3、 QBC（Query By Criteria）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#131qbc查询的基本步骤&quot; id=&quot;markdown-toc-131qbc查询的基本步骤&quot;&gt;1.3.1、QBC查询的基本步骤&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一获取hibernatetemplate&quot;&gt;一、获取HibernateTemplate()&lt;/h2&gt;
spring提供访问数据库的有三种方式： &lt;strong&gt;HibernateDaoSupport，HibernateTemplate，jdbcTemplate&lt;/strong&gt;

Spring与Hibernate整合的过程中,Spring为Hibernate提供了工具类:HibernateDaoSupport,让Dao层实现类继承HibernateDaoSupport去获取HibernateTemplate模板
主要提供了两个方法

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setSessionFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SessionFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sessionFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HibernateTemplate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getHibernateTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
其中setSessionFactory方法用来接收Spring的ApplicationContext的依赖注入，可接收配置在Spring的SessionFactory实例，&lt;strong&gt;getHibernateTemplate方法则用来更具获得SessionFactory产生Session&lt;/strong&gt;，最后生成&lt;code class=&quot;highlighter-rouge&quot;&gt;HibernateTeplate&lt;/code&gt;来完成数据库访问。

Spring配置文件:
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;!-- 引入外部属性sql相关信息=============================== --&amp;gt;
    &amp;lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&amp;gt;

    &amp;lt;!--配置c3p0连接池--&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 引入hibernate的配置信息 --&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!-- 注入连接池 --&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
        &amp;lt;!-- 配置Hibernate的相关属性 --&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hinernate.show_sql&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hinernate.format_sql&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hinernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 设置映射文件 --&amp;gt;
        &amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
            &amp;lt;list&amp;gt;&amp;lt;value&amp;gt;com/spring/domain/Customer.hbm.xml&amp;lt;/value&amp;gt;&amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置DAO --&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; class=&quot;com.spring.dao.impl.CustomerDaoImpl&quot;&amp;gt;
        &amp;lt;!--注入SessionFactory创建Hibernate模板--&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
Customer类:
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cust_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cust_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cust_source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cust_industry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cust_level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cust_phone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cust_mobile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;..........&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//getter() and setter() &lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;二hibernate的三种查询方式&quot;&gt;二、Hibernate的三种查询方式&lt;/h2&gt;
Hibernate总的来说共有三种查询方式：HQL、QBC和SQL三种

&lt;h3 id=&quot;11-hqlhibernate-query-language&quot;&gt;1.1、 HQL（Hibernate Query Language）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似&lt;/li&gt;
  &lt;li&gt;在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式
 与所熟悉的SQL的语法差不太多，不同的就是把表名换成了类或者对象,列换成对象属性
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//Dao层实现类中获取session&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Session&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;session&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  

 &lt;span class=&quot;c1&quot;&gt;//简单属性查询&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;SQLQuery&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createSQLQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;from Customer&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//addEntity()自动封装成对象的类型&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;//条件查询&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Query&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;from Customer s where s.cust_name = ?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%1%&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;			
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    具体参考:&lt;a href=&quot;https://blog.csdn.net/opnmzxcvb/article/details/3966030&quot;&gt;https://blog.csdn.net/opnmzxcvb/article/details/3966030&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-sqlstructured-query-language&quot;&gt;1.2、 SQL（Structured Query Language）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;面向数据库表查询&lt;/li&gt;
  &lt;li&gt;sql就是在dao层直接写sql语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;err&quot;&gt;　&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Session&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;session&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
   &lt;span class=&quot;n&quot;&gt;SQLQuery&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createSQLQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;select * from Customer&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
缺点：违背了hibernate的跨平台优点，不易维护，不面向对象。不推荐使用。

&lt;h3 id=&quot;13-qbcquery-by-criteria&quot;&gt;1.3、 QBC（Query By Criteria）&lt;/h3&gt;

&lt;h4 id=&quot;131qbc查询的基本步骤&quot;&gt;1.3.1、QBC查询的基本步骤&lt;/h4&gt;

这种方式比较面向对象方式，重点是有三个描述条件的对象：Restrictions,Order,Projections。
使用QBC查询，一般需要以下三个步骤：
&lt;ul&gt;
  &lt;li&gt;
    &lt;font size=&quot;3&quot; color=&quot;red&quot;&gt;使用Session对象的createCriteria()方法创建Criteria对象,要注意的一点事是Criteria和DetachedCriteria主要区别是创建形式不同：&lt;/font&gt;
    1、&lt;strong&gt;Criteria是在线的&lt;/strong&gt;，是由Hibernate Session进行创建；&lt;br /&gt;
2、&lt;strong&gt;DetachedCriteria是离线的&lt;/strong&gt;，创建无需session，而是由DetachedCriteria提供了2个静态方法: &lt;code class=&quot;highlighter-rouge&quot;&gt;forClass(Class)&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;forEntityName(Name)&lt;/code&gt;进行DetachedCriteria实例的创建。
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Criteria&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createCriteria&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//它是和在线对应的。Criteria对象是一个在线对象，它是由一个可用的(活动的)Session对象获取的出来的。当Session失效后就无法获取该对象，有一个对象，它也可以用于设置条件，但是获取的时候并不需要Session对象。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DetachedCriteria&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;criteria&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DetachedCriteria&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;font size=&quot;3&quot; color=&quot;red&quot;&gt;使用工具类Restrictions的方法为Criteria对象设置查询条件，Order工具类的方法设置排序方式，Projections工具类的方法进行统计和分组;&lt;/font&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;font size=&quot;3&quot; color=&quot;red&quot;&gt;使用Criteria对象的list()方法进行查询并返回结果。&lt;/font&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/07/Hibernate-DetacheCriteria/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/07/Hibernate-DetacheCriteria/</guid>
        
        <category>CRUD</category>
        
        
        <category>Hibernate</category>
        
      </item>
    
      <item>
        <title>Java NIO:浅析I/O模型(转载)</title>
        <description>
&lt;strong&gt;原博地址:&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3916526.html&quot;&gt;https://www.cnblogs.com/dolphin0520/p/3916526.html&lt;/a&gt;&lt;/strong&gt;

　　也许很多朋友在学习NIO的时候都会感觉有点吃力，对里面的很多概念都感觉不是那么明朗。在进入Java NIO编程之前，我们今天先来讨论一些比较基础的知识：I/O模型。下面本文先从同步和异步的概念 说起，然后接着阐述了阻塞和非阻塞的区别，接着介绍了阻塞IO和非阻塞IO的区别，然后介绍了同步IO和异步IO的区别，接下来介绍了5种IO模型，最后介绍了两种和高性能IO设计相关的设计模式（Reactor和Proactor）。

　　以下是本文的目录大纲：

　　一.什么是同步？什么是异步？

　　二.什么是阻塞？什么是非阻塞？

　　三.什么是阻塞IO？什么是非阻塞IO？

　　四.什么是同步IO？什么是异步IO？

　　五.五种IO模型

　　六.两种高性能IO设计模式

　　若有不正之处，请多多谅解并欢迎批评指正。

</description>
        <pubDate>Sat, 06 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/06/Java-NIO/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/06/Java-NIO/</guid>
        
        <category>并发</category>
        
        <category>io</category>
        
        
        <category>IO</category>
        
      </item>
    
      <item>
        <title>mybatis中mapper的namespace的作用</title>
        <description>在mybatis中，映射文件中的namespace是用于绑定Dao接口的，即面向接口编程。当你的namespace绑定接口后，你&lt;strong&gt;可以不用写接口实现类&lt;/strong&gt;，mybatis会通过该绑定自动帮你找到对应要执行的SQL语句，如下：

假设定义了IArticleDAO接口
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IArticleDAO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Article&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectAllArticle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
对于映射文件如下：
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;namespace=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.xxx.dao.IArticleDAO&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectAllArticle&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;article&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	SELECT t.* FROM T_article t WHERE t.flag = '1' ORDER BY t.createtime DESC
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
接口中的方法与映射文件中的SQL语句的ID一一对应 。
则在代码中可以直接使用IArticeDAO面向接口编程而不需要再编写实现类,

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;重点:namaespace绑定接口,需要获取接口的映射对象(sqlSession.getMapper(xxx.class)),通过映射对象调用方法&lt;code class=&quot;highlighter-rouge&quot;&gt;selectAllArticle()&lt;/code&gt;,方法名对应xml中的id&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;命名空间绑定绑定pojo类&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper namespace=&quot;article&quot;&amp;gt; &lt;/code&gt; ,并且没有articleDao接口和实现类,需要pojo类和xml在同一包下,才能实现query。例如&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlSession.selectById(&quot;article.xxx&quot;,id)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 03 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/03/Mybatis1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/03/Mybatis1/</guid>
        
        <category>Mybatis</category>
        
        
        <category>Mybatis</category>
        
      </item>
    
      <item>
        <title>B树、B+树、B*树结构的理解</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
原文地址(搬运修改):&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/v_JULY_v/article/details/6530142&quot;&gt;从 B 树、B+ 树、B* 树谈到 R 树&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cnblogs.com/vincently/p/4526560.html&quot;&gt;【经典数据结构】B树与B+树&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cnblogs.com/George1994/p/7008732.html&quot;&gt;B树和B+树的总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/zhangbo_0323/article/details/50156357&quot;&gt;对于B树，B+树的理解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cnblogs.com/xqzt/archive/2012/12/28/5637129.html&quot;&gt;B+树、B*树&lt;/a&gt;&lt;br /&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言：&lt;/h2&gt;

</description>
        <pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/02/B-Tree/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/02/B-Tree/</guid>
        
        <category>Tree</category>
        
        
        <category>DataStructure</category>
        
      </item>
    
      <item>
        <title>整理一些学习过的数据结构和算法blog</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#树形结构&quot; id=&quot;markdown-toc-树形结构&quot;&gt;树形结构:&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#算法系列&quot; id=&quot;markdown-toc-算法系列&quot;&gt;算法系列:&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#8大排序&quot; id=&quot;markdown-toc-8大排序&quot;&gt;8大排序:&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#其他基础算法&quot; id=&quot;markdown-toc-其他基础算法&quot;&gt;其他基础算法:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#并发编程&quot; id=&quot;markdown-toc-并发编程&quot;&gt;并发编程:&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#海子大神系列&quot; id=&quot;markdown-toc-海子大神系列&quot;&gt;海子大神系列:&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#skywang大神系列&quot; id=&quot;markdown-toc-skywang大神系列&quot;&gt;skywang大神系列:&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#一-基础篇&quot; id=&quot;markdown-toc-一-基础篇&quot;&gt;(一) 基础篇&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#二-juc原子类&quot; id=&quot;markdown-toc-二-juc原子类&quot;&gt;(二) JUC原子类&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#三-juc锁&quot; id=&quot;markdown-toc-三-juc锁&quot;&gt;(三) JUC锁&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#四-juc集合&quot; id=&quot;markdown-toc-四-juc集合&quot;&gt;(四) JUC集合&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#五-juc线程池&quot; id=&quot;markdown-toc-五-juc线程池&quot;&gt;(五) JUC线程池&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#附加内容&quot; id=&quot;markdown-toc-附加内容&quot;&gt;附加内容&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#面试集合&quot; id=&quot;markdown-toc-面试集合&quot;&gt;面试集合:&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ioip-http-tcp&quot; id=&quot;markdown-toc-ioip-http-tcp&quot;&gt;IO/IP HTTP TCP:&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#书籍&quot; id=&quot;markdown-toc-书籍&quot;&gt;书籍:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;树形结构&quot;&gt;树形结构:&lt;/h2&gt;

&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3576452.html&quot;&gt;二叉查找树&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3576452.html&quot;&gt;二叉查找树之 Java的实现&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/Michaelwjw/p/6384428.html&quot;&gt;二叉搜索树Java实现（查找、插入、删除、遍历） - Michaelwjw - 博客园&lt;/a&gt;

&lt;br /&gt;

&lt;a href=&quot;https://blog.csdn.net/javazejian/article/details/53892797&quot;&gt;AVL树的设计与实现 - CSDN博客&lt;/a&gt;

&lt;a href=&quot;https://www.jianshu.com/p/65c90aa1236d&quot;&gt;彻底搞懂AVL树 - 简书&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3577479.html#a1&quot;&gt;AVL树(三)之 Java的实现 - 如果天空不死 - 博客园&lt;/a&gt;

&lt;br /&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3245399.html&quot;&gt;红黑树(一)之 原理和算法详细介绍&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3624343.html&quot;&gt;红黑树(五)之 Java的实现&lt;/a&gt;

&lt;a href=&quot;https://blog.csdn.net/yang_yulei/article/details/26066409&quot;&gt;查找（一）史上最简单清晰的红黑树讲解 - CSDN博客&lt;/a&gt;

&lt;a href=&quot;https://blog.csdn.net/Sun_TTTT/article/details/65445754&quot;&gt;!最容易懂得红黑树 - CSDN博客&lt;/a&gt;

&lt;a href=&quot;https://blog.csdn.net/yang_yulei/article/details/26066409&quot;&gt;查找（一）史上最简单清晰的红黑树讲解 - CSDN博客&lt;/a&gt;

&lt;br /&gt;

&lt;a href=&quot;http://www.cnblogs.com/gaochundong/p/balanced_search_tree.htm&quot;&gt;查找树（2-3-4 树） - 匠心十年- 博客园&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3711483.html&quot;&gt;图的遍历之 深度优先搜索和广度优先搜索&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3706833.html&quot;&gt;哈夫曼树(三)之 Java详解&lt;/a&gt;

&lt;a href=&quot;https://blog.csdn.net/v_JULY_v/article/details/6530142&quot;&gt;从B树、B+树、B*树谈到R 树&lt;/a&gt;

&lt;a href=&quot;http://blog.csdn.net/hackbuteer1/article/details/7964147&quot;&gt;Trie树详解及其应用&lt;/a&gt;

&lt;br /&gt;

&lt;a href=&quot;https://www.zhihu.com/question/20176446&quot;&gt;数据结构与算法中，树一般会应用在哪些方面？为什么？ - 知乎&lt;/a&gt;

&lt;br /&gt;

&lt;h2 id=&quot;算法系列&quot;&gt;算法系列:&lt;/h2&gt;

&lt;h4 id=&quot;8大排序&quot;&gt;8大排序:&lt;/h4&gt;

&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3596232.html&quot;&gt;冒泡排序&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3596746.html&quot;&gt;快速排序&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3596881.html&quot;&gt;直接插入排序&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3597597.html&quot;&gt;希尔排序&lt;/a&gt;  &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3597641.html&quot;&gt;选择排序&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3602162.html&quot;&gt;堆排序&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3602737.html&quot;&gt;桶排序&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3603669.html&quot;&gt;基数排序&lt;/a&gt;

&lt;h4 id=&quot;其他基础算法&quot;&gt;其他基础算法:&lt;/h4&gt;

&lt;a href=&quot;https://blog.csdn.net/bruce_suxin/article/details/52937720&quot;&gt;递归之斐波那契数列java的三种写法- CSDN博客&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/newflydd/p/5091646.html&quot;&gt;8皇后以及N皇后算法探究，回溯算法的JAVA实现，递归方案&lt;/a&gt;

&lt;a href=&quot;https://blog.csdn.net/m53931422/article/details/41788535&quot;&gt;分治归并排序算法——Java实现- CSDN博客&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/xiaozhang2014/p/7783795.html&quot;&gt;java-贪心算法&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/yanlingyin/archive/2011/11/16/greedy.html&quot;&gt;【贪心法求解最小生成树之Kruskal算法详细分析】—Greedy Algorithm for MST&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3711510.html&quot;&gt;Prim算法(三)之 Java详解&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3711516.html&quot;&gt;Dijkstra算法(三)之Java详解- 如果天空不死- 博客园&lt;/a&gt;

&lt;br /&gt;

&lt;h2 id=&quot;并发编程&quot;&gt;并发编程:&lt;/h2&gt;

&lt;h3 id=&quot;海子大神系列&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/dolphin0520&quot;&gt;海子大神系列&lt;/a&gt;:&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3910667.html&quot;&gt;Java并发编程：进程和线程之由来&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3913517.html&quot;&gt;Java并发编程：如何创建线程？&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920357.html&quot;&gt;Java并发编程：Thread类的使用&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920385.html&quot;&gt;Java并发编程：线程间协作的两种方式：wait、notify、notifyAll和Condition&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3923737.html&quot;&gt;Java并发编程：synchronized&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3923167.html&quot;&gt;Java并发编程：Lock&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920373.html&quot;&gt;Java并发编程：volatile关键字解析&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920407.html&quot;&gt;Java并发编程：深入剖析ThreadLocal&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3933404.html&quot;&gt;Java并发编程：同步容器&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3933551.html&quot;&gt;Java ConcurrentModificationException异常原因和解决方法&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3932905.html&quot;&gt;Java并发编程：并发容器之ConcurrentHashMap（转载）&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3938914.html&quot;&gt;Java并发编程：并发容器之CopyOnWriteArrayList（转载）&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3932906.html&quot;&gt;Java并发编程：阻塞队列&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3932921.html&quot;&gt;Java并发编程：线程池的使用&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920397.html&quot;&gt;Java并发编程：CountDownLatch、CyclicBarrier和Semaphore&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3949310.html&quot;&gt;Java并发编程：Callable、Future和FutureTask&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3938991.html&quot;&gt;Java并发编程：Timer和TimerTask（转载）&lt;/a&gt;

    &lt;br /&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;skywang大神系列&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/skywang12345&quot;&gt;skywang大神系列&lt;/a&gt;:&lt;/h3&gt;

&lt;h4 id=&quot;一-基础篇&quot;&gt;(一) 基础篇&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479024.html&quot;&gt;Java多线程系列–“基础篇”01之 基本概念&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479063.html&quot;&gt;Java多线程系列–“基础篇”02之 常用的实现多线程的两种方式&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479083.html&quot;&gt;Java多线程系列–“基础篇”03之 Thread中start()和run()的区别&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479202.html&quot;&gt;Java多线程系列–“基础篇”04之 synchronized关键字&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479224.html&quot;&gt;Java多线程系列–“基础篇”05之 线程等待与唤醒&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479243.html&quot;&gt;Java多线程系列–“基础篇”06之 线程让步&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479256.html&quot;&gt;Java多线程系列–“基础篇”07之 线程休眠&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479275.html&quot;&gt;Java多线程系列–“基础篇”08之 join()&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479949.html&quot;&gt;Java多线程系列–“基础篇”09之 interrupt()和线程终止方式&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3479982.html&quot;&gt;Java多线程系列–“基础篇”10之 线程优先级和守护线程&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3480016.html&quot;&gt;Java多线程系列–“基础篇”11之 生产消费者问题&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;二-juc原子类&quot;&gt;(二) JUC原子类&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3514589.html&quot;&gt;Java多线程系列–“JUC原子类”01之 框架&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3514593.html&quot;&gt;Java多线程系列–“JUC原子类”02之 AtomicLong原子类&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3514604.html&quot;&gt;Java多线程系列–“JUC原子类”03之 AtomicLongArray原子类&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3514623.html&quot;&gt;Java多线程系列–“JUC原子类”04之 AtomicReference原子类&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3514635.html&quot;&gt;Java多线程系列–“JUC原子类”05之 AtomicLongFieldUpdater原子类&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;三-juc锁&quot;&gt;(三) JUC锁&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3496098.html&quot;&gt;Java多线程系列–“JUC锁”01之 框架&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3496101.html&quot;&gt;Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3496147.html&quot;&gt;Java多线程系列–“JUC锁”03之 公平锁(一)&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3496609.html&quot;&gt;Java多线程系列–“JUC锁”04之 公平锁(二)&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3496651.html&quot;&gt;Java多线程系列–“JUC锁”05之 非公平锁&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3496716.html&quot;&gt;Java多线程系列–“JUC锁”06之 Condition条件&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3505784.html&quot;&gt;Java多线程系列–“JUC锁”07之 LockSupport&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3505809.html&quot;&gt;Java多线程系列–“JUC锁”08之 共享锁和ReentrantReadWriteLock&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3533887.html&quot;&gt;Java多线程系列–“JUC锁”09之 CountDownLatch原理和示例&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3533995.html&quot;&gt;Java多线程系列–“JUC锁”10之 CyclicBarrier原理和示例&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3534050.html&quot;&gt;Java多线程系列–“JUC锁”11之 Semaphore信号量的原理和示例&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;四-juc集合&quot;&gt;(四) JUC集合&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498454.html&quot;&gt;Java多线程系列–“JUC集合”01之 框架&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498483.html&quot;&gt;Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498497.html&quot;&gt;Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498537.html&quot;&gt;Java多线程系列–“JUC集合”04之 ConcurrentHashMap&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498556.html&quot;&gt;Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498634.html&quot;&gt;Java多线程系列–“JUC集合”06之 ConcurrentSkipListSet&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498652.html&quot;&gt;Java多线程系列–“JUC集合”07之 ArrayBlockingQueue&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3503458.html&quot;&gt;Java多线程系列–“JUC集合”08之 LinkedBlockingQueue&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3503480.html&quot;&gt;Java多线程系列–“JUC集合”09之 LinkedBlockingDeque&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3498995.html&quot;&gt;Java多线程系列–“JUC集合”10之 ConcurrentLinkedQueue&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;五-juc线程池&quot;&gt;(五) JUC线程池&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3509903.html&quot;&gt;Java多线程系列–“JUC线程池”01之 线程池架构&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3509941.html&quot;&gt;Java多线程系列–“JUC线程池”02之 线程池原理(一)&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3509954.html&quot;&gt;Java多线程系列–“JUC线程池”03之 线程池原理(二)&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3509960.html&quot;&gt;Java多线程系列–“JUC线程池”04之 线程池原理(三)&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3512947.html&quot;&gt;Java多线程系列–“JUC线程池”05之 线程池原理(四)&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3544116.html&quot;&gt;Java多线程系列–“JUC线程池”06之 Callable和Future&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;附加内容&quot;&gt;附加内容&lt;/h5&gt;

&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3447546.html&quot;&gt;《深入理解Java内存模型》读书总结&lt;/a&gt;

&lt;hr /&gt;

&lt;a href=&quot;http://www.iteye.com/topic/757478&quot;&gt;深入浅出ThreadLocal - Java综合 - Java - ITeye论坛&lt;/a&gt;

&lt;a href=&quot;https://www.jianshu.com/p/98b68c97df9b&quot;&gt;ThreadLocal-面试必问深度解析 - 简书&lt;/a&gt;

&lt;h4 id=&quot;面试集合&quot;&gt;面试集合:&lt;/h4&gt;

&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3958019.html&quot;&gt;Java线程面试题 Top 50 （转载）&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3932934.html&quot;&gt;JAVA多线程和并发基础面试问答（转载）&lt;/a&gt;
&lt;br /&gt;

&lt;h2 id=&quot;ioip-http-tcp&quot;&gt;IO/IP HTTP TCP:&lt;/h2&gt;

&lt;a href=&quot;https://juejin.im/post/5b5ef5a25188251af86bfebf&quot;&gt;HTTP2和HTTPS来不来了解一下？ - 掘金&lt;/a&gt;

&lt;a href=&quot;https://blog.csdn.net/anxpp/article/details/51512200&quot;&gt;Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码） - CSDN博客&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/red-code/p/8394892.html&quot;&gt;TCP协议详解 - Red_Code - 博客园&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/ImBit/p/5513401.html&quot;&gt;基础笔记（三）：网络协议之Tcp、Http - 老真 - 博客园&lt;/a&gt;

&lt;a href=&quot;https://blog.csdn.net/baiye_xing/article/details/73123753&quot;&gt;【NIO引入】BIO、AIO与NIO的区别 - CSDN博客&lt;/a&gt;

&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3916526.html&quot;&gt;Java NIO：浅析I/O模型&lt;/a&gt;

&lt;h2 id=&quot;书籍&quot;&gt;书籍:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.jobbole.com/86734/&quot;&gt;如果有人让你推荐前端技术书，请让他看这个列表 - WEB前端 - 伯乐在线&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/xiaopang1122/article/details/54909636&quot;&gt;JAVA程序员必看的15本书-JAVA自学书籍推荐 （转） - CSDN博客&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1600336783016516283&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;干货 ｜ 推荐五本国外最受欢迎的Spring教程书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 01 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/01/Collections1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/01/Collections1/</guid>
        
        <category>数据结构</category>
        
        <category>算法</category>
        
        
        <category>Algorithm</category>
        
        <category>DataStructure</category>
        
      </item>
    
      <item>
        <title>剑指Offer--根据前序遍历和中序遍历重建二叉树</title>
        <description>&lt;strong&gt;题目：&lt;/strong&gt;
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{1,2,4,7,3,5,6,8}，则重建二叉树并返回。

&lt;img src=&quot;/images/360截图16400227446291.png&quot; alt=&quot;&quot; /&gt;

二叉树前序遍历Preorder Traversal: 根-左-右&lt;code class=&quot;highlighter-rouge&quot;&gt;{1,2,4,7,3,5,6,8}&lt;/code&gt;&lt;br /&gt;

二叉树中序遍历Inorder Traversal: 左-根-右&lt;code class=&quot;highlighter-rouge&quot;&gt;{1,2,4,7,3,5,6,8}&lt;/code&gt;&lt;br /&gt;

&lt;ol&gt;
  &lt;li&gt;可以判断出&lt;strong&gt;前序遍历第一点&lt;/strong&gt;一定是根节点,然后在根据 利用while循环找出&lt;strong&gt;中序遍历的根节点&lt;/strong&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;根据根节点判断出中序遍历左边部分是左子树,右边是右子树;&lt;/li&gt;
  &lt;li&gt;根据中序遍历了第一点和根节点判断偏移量&lt;code class=&quot;highlighter-rouge&quot;&gt; index-startIn&lt;/code&gt;(循环第一次是index为3);&lt;/li&gt;
  &lt;li&gt;中序遍历根节点左边第一点就是左子树最后一个节点(最大点)&lt;code class=&quot;highlighter-rouge&quot;&gt;index-startIn +startPre&lt;/code&gt; (前序第一点加偏移量);&lt;/li&gt;
  &lt;li&gt;前序遍历左子树最后一个节点的后一点 &lt;code class=&quot;highlighter-rouge&quot;&gt;index-startIn+startPre+1&lt;/code&gt;就是右子树第一点,&lt;code class=&quot;highlighter-rouge&quot;&gt;index+1&lt;/code&gt;中序遍历右子树的第一点;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 30 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/30/Sword-refers-to-Offer1-Copy/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/30/Sword-refers-to-Offer1-Copy/</guid>
        
        <category>Tree</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
  </channel>
</rss>
